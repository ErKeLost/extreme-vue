{"version":3,"sources":["../src/index.ts","../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts","../src/ref.ts","../src/computed.ts"],"sourcesContent":["export {\n  reactive,\n  readonly,\n  shallowReadonly,\n  isReadonly,\n  isReactive,\n  isProxy,\n} from './reactive'\n\nexport { ref, proxyRefs, unRef, isRef } from \"./ref\";\n// export { ref } from './ref'\n\nexport { effect } from './effect'\n\nexport { computed } from \"./computed\";\n","export * from \"../src/shapeFlags\";\nexport * from \"../src/toDisplayString\";\n\nexport const isObject = (val) => {\n  return val !== null && typeof val === \"object\";\n};\n\nexport const isString = (val) => typeof val === \"string\";\n\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n * 把烤肉串命名方式转换成驼峰命名方式\n */\nexport const camelize = (str: string): string => {\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : \"\"));\n};\n\nexport const extend = Object.assign;\n\n// 必须是 on+一个大写字母的格式开头\nexport const isOn = (key) => /^on[A-Z]/.test(key);\n\nexport function hasChanged(value, oldValue) {\n  return !Object.is(value, oldValue);\n}\n\nexport function hasOwn(val, key) {\n  return Object.prototype.hasOwnProperty.call(val, key);\n}\n\n/**\n * @private\n * 首字母大写\n */\nexport const capitalize = (str: string) =>\n  str.charAt(0).toUpperCase() + str.slice(1);\n\n/**\n * @private\n * 添加 on 前缀，并且首字母大写\n */\nexport const toHandlerKey = (str: string) =>\n  str ? `on${capitalize(str)}` : ``;\n\n// 用来匹配 kebab-case 的情况\n// 比如 onTest-event 可以匹配到 T\n// 然后取到 T 在前面加一个 - 就可以\n// \\BT 就可以匹配到 T 前面是字母的位置\nconst hyphenateRE = /\\B([A-Z])/g;\n/**\n * @private\n */\nexport const hyphenate = (str: string) =>\n  str.replace(hyphenateRE, \"-$1\").toLowerCase();\n","import { extend } from '../../shared/src/index'\n\nlet activeEffect\nlet shouldTrack\nexport class ReactiveEffect {\n  deps = []\n  activeStop = true\n  // 可有可无\n  onStop?: () => void\n  constructor(public fn, public scheduler?) {}\n  run() {\n    // 1. 会收集依赖\n    if (!this.activeStop) {\n      return this.fn()\n    }\n    shouldTrack = true\n    activeEffect = this\n    const res = this.fn()\n    shouldTrack = false\n    return res\n  }\n  stop() {\n    if (this.activeStop) {\n      cleanupEffect(this)\n      if (this.onStop) {\n        this.onStop()\n      }\n      this.activeStop = false\n    }\n  }\n}\nfunction cleanupEffect(effect) {\n  effect.deps.forEach((dep: any) => {\n    dep.delete(effect)\n  })\n  effect.deps.length = 0\n}\nconst targetMap = new Map()\nexport function track(target, key) {\n  // 一开始没有 activeEffect\n  // if (!activeEffect) return\n  // 防止 同时触发 get 和 set 操作 他还是会收集到依赖 stop 会失效\n  // if (!shouldTrack) return\n  if (!isTracking()) {\n    return\n  }\n  // target -> key -> dep\n  let depsMap = targetMap.get(target)\n  if (!depsMap) {\n    depsMap = new Map()\n    targetMap.set(target, depsMap)\n  }\n  let dep = depsMap.get(key)\n  if (!dep) {\n    dep = new Set()\n    depsMap.set(key, dep)\n  }\n  trackEffect(dep)\n}\nexport function trackEffect(dep) {\n  if (dep.has(activeEffect)) return\n  dep.add(activeEffect)\n  activeEffect.deps.push(dep)\n}\n\nexport function triggerEffect(dep) {\n  for (const effect of dep) {\n    if (effect.scheduler) {\n      effect.scheduler()\n    } else {\n      effect.run()\n    }\n  }\n}\nexport function trigger(target, key) {\n  // 取出所有 收集到的依赖 进行遍历\n  let depsMap = targetMap.get(target)\n  let dep = depsMap.get(key)\n  triggerEffect(dep)\n}\n\nexport function effect(fn, options: any = {}) {\n  const _effect = new ReactiveEffect(fn, options.scheduler)\n  extend(_effect, options)\n  console.log(_effect)\n  _effect.run()\n  const runner: any = _effect.run.bind(_effect)\n  runner.effect = _effect\n  return runner\n}\n\nexport function isTracking() {\n  return shouldTrack && activeEffect !== undefined\n}\nexport function stop(runner) {\n  runner.effect.stop()\n}\n\n// import { createDep } from \"./dep\";\n// import { extend } from \"@relaxed/shared\";\n\n// let activeEffect = void 0;\n// let shouldTrack = false;\n// const targetMap = new WeakMap();\n\n// // 用于依赖收集\n// export class ReactiveEffect {\n//   active = true;\n//   deps = [];\n//   public onStop?: () => void;\n//   constructor(public fn, public scheduler?) {\n//     console.log(\"创建 ReactiveEffect 对象\");\n//   }\n\n//   run() {\n//     console.log(\"run\");\n//     // 运行 run 的时候，可以控制 要不要执行后续收集依赖的一步\n//     // 目前来看的话，只要执行了 fn 那么就默认执行了收集依赖\n//     // 这里就需要控制了\n\n//     // 是不是收集依赖的变量\n\n//     // 执行 fn  但是不收集依赖\n//     if (!this.active) {\n//       return this.fn();\n//     }\n\n//     // 执行 fn  收集依赖\n//     // 可以开始收集依赖了\n//     shouldTrack = true;\n\n//     // 执行的时候给全局的 activeEffect 赋值\n//     // 利用全局属性来获取当前的 effect\n//     activeEffect = this as any;\n//     // 执行用户传入的 fn\n//     console.log(\"执行用户传入的 fn\");\n//     const result = this.fn();\n//     // 重置\n//     shouldTrack = false;\n//     activeEffect = undefined;\n\n//     return result;\n//   }\n\n//   stop() {\n//     if (this.active) {\n//       // 如果第一次执行 stop 后 active 就 false 了\n//       // 这是为了防止重复的调用，执行 stop 逻辑\n//       cleanupEffect(this);\n//       if (this.onStop) {\n//         this.onStop();\n//       }\n//       this.active = false;\n//     }\n//   }\n// }\n\n// function cleanupEffect(effect) {\n//   // 找到所有依赖这个 effect 的响应式对象\n//   // 从这些响应式对象里面把 effect 给删除掉\n//   effect.deps.forEach((dep) => {\n//     dep.delete(effect);\n//   });\n\n//   effect.deps.length = 0;\n// }\n\n// export function effect(fn, options = {}) {\n//   const _effect = new ReactiveEffect(fn);\n\n//   // 把用户传过来的值合并到 _effect 对象上去\n//   // 缺点就是不是显式的，看代码的时候并不知道有什么值\n//   extend(_effect, options);\n//   _effect.run();\n\n//   // 把 _effect.run 这个方法返回\n//   // 让用户可以自行选择调用的时机（调用 fn）\n//   const runner: any = _effect.run.bind(_effect);\n//   runner.effect = _effect;\n//   return runner;\n// }\n\n// export function stop(runner) {\n//   runner.effect.stop();\n// }\n\n// export function track(target, type, key) {\n//   if (!isTracking()) {\n//     return;\n//   }\n//   console.log(`触发 track -> target: ${target} type:${type} key:${key}`);\n//   // 1. 先基于 target 找到对应的 dep\n//   // 如果是第一次的话，那么就需要初始化\n//   let depsMap = targetMap.get(target);\n//   if (!depsMap) {\n//     // 初始化 depsMap 的逻辑\n//     depsMap = new Map();\n//     targetMap.set(target, depsMap);\n//   }\n\n//   let dep = depsMap.get(key);\n\n//   if (!dep) {\n//     dep = createDep();\n\n//     depsMap.set(key, dep);\n//   }\n\n//   trackEffects(dep);\n// }\n\n// export function trackEffects(dep) {\n//   // 用 dep 来存放所有的 effect\n\n//   // TODO\n//   // 这里是一个优化点\n//   // 先看看这个依赖是不是已经收集了，\n//   // 已经收集的话，那么就不需要在收集一次了\n//   // 可能会影响 code path change 的情况\n//   // 需要每次都 cleanupEffect\n//   // shouldTrack = !dep.has(activeEffect!);\n//   if (!dep.has(activeEffect)) {\n//     dep.add(activeEffect);\n//     (activeEffect as any).deps.push(dep);\n//   }\n// }\n\n// export function trigger(target, type, key) {\n//   // 1. 先收集所有的 dep 放到 deps 里面，\n//   // 后面会统一处理\n//   let deps: Array<any> = [];\n//   // dep\n\n//   const depsMap = targetMap.get(target);\n\n//   if (!depsMap) return;\n\n//   // 暂时只实现了 GET 类型\n//   // get 类型只需要取出来就可以\n//   const dep = depsMap.get(key);\n\n//   // 最后收集到 deps 内\n//   deps.push(dep);\n\n//   const effects: Array<any> = [];\n//   deps.forEach((dep) => {\n//     // 这里解构 dep 得到的是 dep 内部存储的 effect\n//     effects.push(...dep);\n//   });\n//   // 这里的目的是只有一个 dep ，这个dep 里面包含所有的 effect\n//   // 这里的目前应该是为了 triggerEffects 这个函数的复用\n//   triggerEffects(createDep(effects));\n// }\n\n// export function isTracking() {\n//   return shouldTrack && activeEffect !== undefined;\n// }\n\n// export function triggerEffects(dep) {\n//   // 执行收集到的所有的 effect 的 run 方法\n//   for (const effect of dep) {\n//     if (effect.scheduler) {\n//       // scheduler 可以让用户自己选择调用的时机\n//       // 这样就可以灵活的控制调用了\n//       // 在 runtime-core 中，就是使用了 scheduler 实现了在 next ticker 中调用的逻辑\n//       effect.scheduler();\n//     } else {\n//       effect.run();\n//     }\n//   }\n// }\n","import { extend, isObject } from '../../shared/src/index'\nimport { track, trigger } from './effect'\nimport { reactive, ReactiveFlags, readonly } from './reactive'\n\n// 缓存一个getter & setter\nconst get = createGetter()\nconst set = createSetter()\nconst readonlyGet = createGetter(true)\nconst shallowReadonlyGet = createGetter(true, true)\n// 高阶函数判断逻辑\nexport function createGetter(isReadonly = false, shallow = false) {\n  return function get(target, key) {\n    const res = Reflect.get(target, key)\n    // track\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly\n    }\n    if (shallow) {\n      return res\n    }\n    // 嵌套reactive 如果 res 返回的是一个 object 那么我们就再次调用\n    // 转换为reactive\n    if (isObject(res)) {\n      return isReadonly ? readonly(res) : reactive(res)\n    }\n    if (!isReadonly) {\n      track(target, key)\n    }\n    // console.log(\"触发get\");\n    return res\n  }\n}\n\nexport function createSetter() {\n  return function set(target, key, value) {\n    const res = Reflect.set(target, key, value)\n    // trigger\n    trigger(target, key)\n    // console.log(\"触发set\");\n    return res\n  }\n}\n\nexport const mutableHandlers = {\n  get,\n  set,\n}\nexport const readonlyHandlers = {\n  get: readonlyGet,\n  set(target, key, value) {\n    console.warn(`${key} is not change ${target} is read-only`)\n    return true\n  },\n}\n\nexport const shadowReadonlyHandlers = extend({}, readonlyHandlers, {\n  get: shallowReadonlyGet,\n})\n\n// import { ReactiveEffect, track, trigger } from \"./effect\";\n// import {\n//   reactive,\n//   ReactiveFlags,\n//   reactiveMap,\n//   readonly,\n//   readonlyMap,\n//   shallowReadonlyMap,\n// } from \"./reactive\";\n// import { isObject } from \"@relaxed/shared\";\n\n// const get = createGetter();\n// const set = createSetter();\n// const readonlyGet = createGetter(true);\n// const shallowReadonlyGet = createGetter(true, true);\n\n// function createGetter(isReadonly = false, shallow = false) {\n//   return function get(target, key, receiver) {\n//     const isExistInReactiveMap = () =>\n//       key === ReactiveFlags.RAW && receiver === reactiveMap.get(target);\n\n//     const isExistInReadonlyMap = () =>\n//       key === ReactiveFlags.RAW && receiver === readonlyMap.get(target);\n\n//     const isExistInShallowReadonlyMap = () =>\n//       key === ReactiveFlags.RAW && receiver === shallowReadonlyMap.get(target);\n\n//     if (key === ReactiveFlags.IS_REACTIVE) {\n//       return !isReadonly;\n//     } else if (key === ReactiveFlags.IS_READONLY) {\n//       return isReadonly;\n//     } else if (\n//       isExistInReactiveMap() ||\n//       isExistInReadonlyMap() ||\n//       isExistInShallowReadonlyMap()\n//     ) {\n//       return target;\n//     }\n\n//     const res = Reflect.get(target, key, receiver);\n\n//     // 问题：为什么是 readonly 的时候不做依赖收集呢\n//     // readonly 的话，是不可以被 set 的， 那不可以被 set 就意味着不会触发 trigger\n//     // 所有就没有收集依赖的必要了\n\n//     if (!isReadonly) {\n//       // 在触发 get 的时候进行依赖收集\n//       track(target, \"get\", key);\n//     }\n\n//     if (shallow) {\n//       return res;\n//     }\n\n//     if (isObject(res)) {\n//       // 把内部所有的是 object 的值都用 reactive 包裹，变成响应式对象\n//       // 如果说这个 res 值是一个对象的话，那么我们需要把获取到的 res 也转换成 reactive\n//       // res 等于 target[key]\n//       return isReadonly ? readonly(res) : reactive(res);\n//     }\n\n//     return res;\n//   };\n// }\n\n// function createSetter() {\n//   return function set(target, key, value, receiver) {\n//     const result = Reflect.set(target, key, value, receiver);\n\n//     // 在触发 set 的时候进行触发依赖\n//     trigger(target, \"set\", key);\n\n//     return result;\n//   };\n// }\n\n// export const readonlyHandlers = {\n//   get: readonlyGet,\n//   set(target, key) {\n//     // readonly 的响应式对象不可以修改值\n//     console.warn(\n//       `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n//       target\n//     );\n//     return true;\n//   },\n// };\n\n// export const mutableHandlers = {\n//   get,\n//   set,\n// };\n\n// export const shallowReadonlyHandlers = {\n//   get: shallowReadonlyGet,\n//   set(target, key) {\n//     // readonly 的响应式对象不可以修改值\n//     console.warn(\n//       `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n//       target\n//     );\n//     return true;\n//   },\n// };\n","import { mutableHandlers, readonlyHandlers, shadowReadonlyHandlers } from './baseHandlers'\n\n// 是一个reactive\nexport const enum ReactiveFlags {\n  IS_REACTIVE = '_v_isReactive',\n  IS_READONLY = '_v_isReadonly',\n}\n// true  false 判断是否是 readonly\nexport function reactive(raw) {\n  return createReactiveObject(raw, mutableHandlers)\n}\n\nexport function readonly(raw) {\n  return createReactiveObject(raw, readonlyHandlers)\n}\n\nexport function shallowReadonly(raw) {\n  return createReactiveObject(raw, shadowReadonlyHandlers)\n}\n\nexport function isProxy(raw) {\n  return isReactive(raw) || isReadonly(raw)\n}\n\nexport function isReactive(raw) {\n  // 如果是原始对象没有 proxy 代理 是undefined 转成 boolean\n  return !!raw[ReactiveFlags.IS_REACTIVE]\n}\nexport function isReadonly(raw) {\n  return !!raw[ReactiveFlags.IS_READONLY]\n}\n\nfunction createReactiveObject(raw, Handlers) {\n  return new Proxy(raw, Handlers)\n}\n\n// import {\n//   mutableHandlers,\n//   readonlyHandlers,\n//   shallowReadonlyHandlers,\n// } from \"./baseHandlers\";\n\n// export const reactiveMap = new WeakMap();\n// export const readonlyMap = new WeakMap();\n// export const shallowReadonlyMap = new WeakMap();\n\n// export const enum ReactiveFlags {\n//   IS_REACTIVE = \"__v_isReactive\",\n//   IS_READONLY = \"__v_isReadonly\",\n//   RAW = \"__v_raw\",\n// }\n\n// export function reactive(target) {\n//   return createReactiveObject(target, reactiveMap, mutableHandlers);\n// }\n\n// export function readonly(target) {\n//   return createReactiveObject(target, readonlyMap, readonlyHandlers);\n// }\n\n// export function shallowReadonly(target) {\n//   return createReactiveObject(\n//     target,\n//     shallowReadonlyMap,\n//     shallowReadonlyHandlers\n//   );\n// }\n\n// export function isProxy(value) {\n//   return isReactive(value) || isReadonly(value);\n// }\n\n// export function isReadonly(value) {\n//   return !!value[ReactiveFlags.IS_READONLY];\n// }\n\n// export function isReactive(value) {\n//   // 如果 value 是 proxy 的话\n//   // 会触发 get 操作，而在 createGetter 里面会判断\n//   // 如果 value 是普通对象的话\n//   // 那么会返回 undefined ，那么就需要转换成布尔值\n//   return !!value[ReactiveFlags.IS_REACTIVE];\n// }\n\n// export function toRaw(value) {\n//   // 如果 value 是 proxy 的话 ,那么直接返回就可以了\n//   // 因为会触发 createGetter 内的逻辑\n//   // 如果 value 是普通对象的话，\n//   // 我们就应该返回普通对象\n//   // 只要不是 proxy ，只要是得到了 undefined 的话，那么就一定是普通对象\n//   // TODO 这里和源码里面实现的不一样，不确定后面会不会有问题\n//   if (!value[ReactiveFlags.RAW]) {\n//     return value;\n//   }\n\n//   return value[ReactiveFlags.RAW];\n// }\n\n// function createReactiveObject(target, proxyMap, baseHandlers) {\n//   // 核心就是 proxy\n//   // 目的是可以侦听到用户 get 或者 set 的动作\n\n//   // 如果命中的话就直接返回就好了\n//   // 使用缓存做的优化点\n//   const existingProxy = proxyMap.get(target);\n//   if (existingProxy) {\n//     return existingProxy;\n//   }\n\n//   const proxy = new Proxy(target, baseHandlers);\n\n//   // 把创建好的 proxy 给存起来，\n//   proxyMap.set(target, proxy);\n//   return proxy;\n// }\n","// import { trackEffects, triggerEffects, isTracking } from \"./effect\";\n// import { createDep } from \"./dep\";\nimport { isObject, hasChanged } from \"../../shared/src/index\";\nimport { reactive } from \"./reactive\";\nimport { trackEffect, triggerEffect, isTracking } from \"./effect\";\n\nclass RefImpl {\n  private _value: any;\n  private _rawValue: any;\n  // 判断是否是一个ref\n  public __v_isRef = true;\n  // 创建一个dep 收集依赖\n  public dep;\n  constructor(value) {\n    // 存储 原始普通对象的value值 用于对比\n    this._rawValue = value;\n    this._value = convert(value);\n    // 判断value 是不是对象 是对象就装换成reactive\n\n    this.dep = new Set();\n  }\n  get value() {\n    trackRefValue(this);\n    // ref 只监听一个 value 的变化 value的依赖收集\n    return this._value;\n  }\n  set value(newValue) {\n    // 如果value 是一个 对象 就会被转换成reactive 新的值 是 proxy 对比 要转换成普通对象\n    // if (hasChanged(newValue, this._value)) {\n    if (hasChanged(newValue, this._rawValue)) {\n      // if (Object.is(newValue, this._value)) return\n      // 必须要先修改value的值 再去通知\n      this._rawValue = newValue;\n      this._value = convert(newValue);\n      triggerEffect(this.dep);\n    }\n  }\n}\n\nexport function ref(value) {\n  return new RefImpl(value);\n}\n\nexport function isRef(ref) {\n  return !!ref.__v_isRef;\n}\n\nexport function unRef(ref) {\n  return isRef(ref) ? ref.value : ref;\n}\n\nexport function proxyRefs(ref) {\n  // 判断调用了 get 或者 set/\n  return new Proxy(ref, {\n    get(target, key) {\n      return unRef(Reflect.get(target, key));\n    },\n    // 判断set的时候 是不是一个 ref 是 ref 就调用 .value\n    set(target, key, value) {\n      if (isRef(target[key]) && !isRef(value)) {\n        return (target[key].value = value);\n      } else {\n        return Reflect.set(target, key, value);\n      }\n    },\n  });\n}\n\nfunction trackRefValue(ref) {\n  if (isTracking()) {\n    trackEffect(ref.dep);\n  }\n}\n\n// 判断 返回 reactive 对象 还是普通对象\nfunction convert(value) {\n  return isObject(value) ? reactive(value) : value;\n}\n\n// export class RefImpl {\n//   private _rawValue: any;\n//   private _value: any;\n//   public dep;\n//   public __v_isRef = true;\n\n//   constructor(value) {\n//     this._rawValue = value;\n//     // 看看value 是不是一个对象，如果是一个对象的话\n//     // 那么需要用 reactive 包裹一下\n//     this._value = convert(value);\n//     this.dep = createDep();\n//   }\n\n//   get value() {\n//     // 收集依赖\n//     trackRefValue(this);\n//     return this._value;\n//   }\n\n//   set value(newValue) {\n//     // 当新的值不等于老的值的话，\n//     // 那么才需要触发依赖\n//     if (hasChanged(newValue, this._rawValue)) {\n//       // 更新值\n//       this._value = convert(newValue);\n//       this._rawValue = newValue;\n//       // 触发依赖\n//       triggerRefValue(this);\n//     }\n//   }\n// }\n\n// export function ref(value) {\n//   return createRef(value);\n// }\n\n// function convert(value) {\n//   return isObject(value) ? reactive(value) : value;\n// }\n\n// function createRef(value) {\n//   const refImpl = new RefImpl(value);\n\n//   return refImpl;\n// }\n\n// export function triggerRefValue(ref) {\n//   triggerEffects(ref.dep);\n// }\n\n// export function trackRefValue(ref) {\n//   if (isTracking()) {\n//     trackEffects(ref.dep);\n//   }\n// }\n\n// // 这个函数的目的是\n// // 帮助解构 ref\n// // 比如在 template 中使用 ref 的时候，直接使用就可以了\n// // 例如： const count = ref(0) -> 在 template 中使用的话 可以直接 count\n// // 解决方案就是通过 proxy 来对 ref 做处理\n\n// const shallowUnwrapHandlers = {\n//   get(target, key, receiver) {\n//     // 如果里面是一个 ref 类型的话，那么就返回 .value\n//     // 如果不是的话，那么直接返回value 就可以了\n//     return unRef(Reflect.get(target, key, receiver));\n//   },\n//   set(target, key, value, receiver) {\n//     const oldValue = target[key];\n//     if (isRef(oldValue) && !isRef(value)) {\n//       return (target[key].value = value);\n//     } else {\n//       return Reflect.set(target, key, value, receiver);\n//     }\n//   },\n// };\n\n// // 这里没有处理 objectWithRefs 是 reactive 类型的时候\n// // TODO reactive 里面如果有 ref 类型的 key 的话， 那么也是不需要调用 ref.value 的\n// // （but 这个逻辑在 reactive 里面没有实现）\n// export function proxyRefs(objectWithRefs) {\n//   return new Proxy(objectWithRefs, shallowUnwrapHandlers);\n// }\n\n// // 把 ref 里面的值拿到\n// export function unRef(ref) {\n//   return isRef(ref) ? ref.value : ref;\n// }\n\n// export function isRef(value) {\n//   return !!value.__v_isRef;\n// }\n","// import { createDep } from \"./dep\";\nimport { ReactiveEffect } from './effect'\n// import { trackRefValue, triggerRefValue } from \"./ref\";\n\nclass ComputedRefImpl {\n  private _getter\n  private _dirty: boolean = true\n  private _value: any\n  private _effect: ReactiveEffect\n  constructor(getter) {\n    this._getter = getter\n\n    this._effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true\n      }\n    })\n  }\n  get value() {\n    // 调用一次之后 做一个缓存机制\n    // 等依赖的数据发生响应式之后 我们再次执行 getter 把dirty变成true\n    if (this._dirty) {\n      this._dirty = false\n      this._value = this._effect.run()\n      // this._value = this._getter()\n      // return this._getter()\n    }\n    return this._value\n  }\n}\n\nexport function computed(getter) {\n  return new ComputedRefImpl(getter)\n}\n\n// import { createDep } from \"./dep\";\n// import { ReactiveEffect } from \"./effect\";\n// import { trackRefValue, triggerRefValue } from \"./ref\";\n\n// export class ComputedRefImpl {\n//   public dep: any;\n//   public effect: ReactiveEffect;\n\n//   private _dirty: boolean;\n//   private _value\n\n//   constructor(getter) {\n//     this._dirty = true;\n//     this.dep = createDep();\n//     this.effect = new ReactiveEffect(getter, () => {\n//       // scheduler\n//       // 只要触发了这个函数说明响应式对象的值发生改变了\n//       // 那么就解锁，后续在调用 get 的时候就会重新执行，所以会得到最新的值\n//       if (this._dirty) return;\n\n//       this._dirty = true;\n//       triggerRefValue(this);\n//     });\n//   }\n\n//   get value() {\n//     // 收集依赖\n//     trackRefValue(this);\n//     // 锁上，只可以调用一次\n//     // 当数据改变的时候才会解锁\n//     // 这里就是缓存实现的核心\n//     // 解锁是在 scheduler 里面做的\n//     if (this._dirty) {\n//       this._dirty = false;\n//       // 这里执行 run 的话，就是执行用户传入的 fn\n//       this._value = this.effect.run();\n//     }\n\n//     return this._value;\n//   }\n// }\n\n// export function computed(getter) {\n//   return new ComputedRefImpl(getter);\n// }\n"],"mappings":"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","names":["effect","isReadonly","get","set","ref"]}