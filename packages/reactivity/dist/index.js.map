{"version":3,"sources":["../src/index.ts","../src/dep.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts","../src/ref.ts","../src/computed.ts"],"sourcesContent":["export {\n  reactive,\n  readonly,\n  shallowReadonly,\n  isReadonly,\n  isReactive,\n  isProxy,\n} from \"./reactive\";\n\nexport { ref, proxyRefs, unRef, isRef } from \"./ref\";\n\nexport { effect, stop, ReactiveEffect } from \"./effect\";\n\nexport { computed } from \"./computed\";\n","// 用于存储所有的 effect 对象\nexport function createDep(effects?) {\n  const dep = new Set(effects);\n  return dep;\n}\n","import { createDep } from \"./dep\";\nimport { extend } from \"@relaxed/shared\";\n\nlet activeEffect = void 0;\nlet shouldTrack = false;\nconst targetMap = new WeakMap();\n\n// 用于依赖收集\nexport class ReactiveEffect {\n  active = true;\n  deps = [];\n  public onStop?: () => void;\n  constructor(public fn, public scheduler?) {\n    console.log(\"创建 ReactiveEffect 对象\");\n  }\n\n  run() {\n    console.log(\"run\");\n    // 运行 run 的时候，可以控制 要不要执行后续收集依赖的一步\n    // 目前来看的话，只要执行了 fn 那么就默认执行了收集依赖\n    // 这里就需要控制了\n\n    // 是不是收集依赖的变量\n\n    // 执行 fn  但是不收集依赖\n    if (!this.active) {\n      return this.fn();\n    }\n\n    // 执行 fn  收集依赖\n    // 可以开始收集依赖了\n    shouldTrack = true;\n\n    // 执行的时候给全局的 activeEffect 赋值\n    // 利用全局属性来获取当前的 effect\n    activeEffect = this as any;\n    // 执行用户传入的 fn\n    console.log(\"执行用户传入的 fn\");\n    const result = this.fn();\n    // 重置\n    shouldTrack = false;\n    activeEffect = undefined;\n\n    return result;\n  }\n\n  stop() {\n    if (this.active) {\n      // 如果第一次执行 stop 后 active 就 false 了\n      // 这是为了防止重复的调用，执行 stop 逻辑\n      cleanupEffect(this);\n      if (this.onStop) {\n        this.onStop();\n      }\n      this.active = false;\n    }\n  }\n}\n\nfunction cleanupEffect(effect) {\n  // 找到所有依赖这个 effect 的响应式对象\n  // 从这些响应式对象里面把 effect 给删除掉\n  effect.deps.forEach((dep) => {\n    dep.delete(effect);\n  });\n\n  effect.deps.length = 0;\n}\n\nexport function effect(fn, options = {}) {\n  const _effect = new ReactiveEffect(fn);\n\n  // 把用户传过来的值合并到 _effect 对象上去\n  // 缺点就是不是显式的，看代码的时候并不知道有什么值\n  extend(_effect, options);\n  _effect.run();\n\n  // 把 _effect.run 这个方法返回\n  // 让用户可以自行选择调用的时机（调用 fn）\n  const runner: any = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\n\nexport function stop(runner) {\n  runner.effect.stop();\n}\n\nexport function track(target, type, key) {\n  if (!isTracking()) {\n    return;\n  }\n  console.log(`触发 track -> target: ${target} type:${type} key:${key}`);\n  // 1. 先基于 target 找到对应的 dep\n  // 如果是第一次的话，那么就需要初始化\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    // 初始化 depsMap 的逻辑\n    depsMap = new Map();\n    targetMap.set(target, depsMap);\n  }\n\n  let dep = depsMap.get(key);\n\n  if (!dep) {\n    dep = createDep();\n\n    depsMap.set(key, dep);\n  }\n\n  trackEffects(dep);\n}\n\nexport function trackEffects(dep) {\n  // 用 dep 来存放所有的 effect\n\n  // TODO\n  // 这里是一个优化点\n  // 先看看这个依赖是不是已经收集了，\n  // 已经收集的话，那么就不需要在收集一次了\n  // 可能会影响 code path change 的情况\n  // 需要每次都 cleanupEffect\n  // shouldTrack = !dep.has(activeEffect!);\n  if (!dep.has(activeEffect)) {\n    dep.add(activeEffect);\n    (activeEffect as any).deps.push(dep);\n  }\n}\n\nexport function trigger(target, type, key) {\n  // 1. 先收集所有的 dep 放到 deps 里面，\n  // 后面会统一处理\n  let deps: Array<any> = [];\n  // dep\n\n  const depsMap = targetMap.get(target);\n\n  if (!depsMap) return;\n\n  // 暂时只实现了 GET 类型\n  // get 类型只需要取出来就可以\n  const dep = depsMap.get(key);\n\n  // 最后收集到 deps 内\n  deps.push(dep);\n\n  const effects: Array<any> = [];\n  deps.forEach((dep) => {\n    // 这里解构 dep 得到的是 dep 内部存储的 effect\n    effects.push(...dep);\n  });\n  // 这里的目的是只有一个 dep ，这个dep 里面包含所有的 effect\n  // 这里的目前应该是为了 triggerEffects 这个函数的复用\n  triggerEffects(createDep(effects));\n}\n\nexport function isTracking() {\n  return shouldTrack && activeEffect !== undefined;\n}\n\nexport function triggerEffects(dep) {\n  // 执行收集到的所有的 effect 的 run 方法\n  for (const effect of dep) {\n    if (effect.scheduler) {\n      // scheduler 可以让用户自己选择调用的时机\n      // 这样就可以灵活的控制调用了\n      // 在 runtime-core 中，就是使用了 scheduler 实现了在 next ticker 中调用的逻辑\n      effect.scheduler();\n    } else {\n      effect.run();\n    }\n  }\n}\n","import { ReactiveEffect, track, trigger } from \"./effect\";\nimport {\n  reactive,\n  ReactiveFlags,\n  reactiveMap,\n  readonly,\n  readonlyMap,\n  shallowReadonlyMap,\n} from \"./reactive\";\nimport { isObject } from \"@relaxed/shared\";\n\nconst get = createGetter();\nconst set = createSetter();\nconst readonlyGet = createGetter(true);\nconst shallowReadonlyGet = createGetter(true, true);\n\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target, key, receiver) {\n    const isExistInReactiveMap = () =>\n      key === ReactiveFlags.RAW && receiver === reactiveMap.get(target);\n\n    const isExistInReadonlyMap = () =>\n      key === ReactiveFlags.RAW && receiver === readonlyMap.get(target);\n\n    const isExistInShallowReadonlyMap = () =>\n      key === ReactiveFlags.RAW && receiver === shallowReadonlyMap.get(target);\n\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly;\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly;\n    } else if (\n      isExistInReactiveMap() ||\n      isExistInReadonlyMap() ||\n      isExistInShallowReadonlyMap()\n    ) {\n      return target;\n    }\n\n    const res = Reflect.get(target, key, receiver);\n\n    // 问题：为什么是 readonly 的时候不做依赖收集呢\n    // readonly 的话，是不可以被 set 的， 那不可以被 set 就意味着不会触发 trigger\n    // 所有就没有收集依赖的必要了\n\n    if (!isReadonly) {\n      // 在触发 get 的时候进行依赖收集\n      track(target, \"get\", key);\n    }\n\n    if (shallow) {\n      return res;\n    }\n\n    if (isObject(res)) {\n      // 把内部所有的是 object 的值都用 reactive 包裹，变成响应式对象\n      // 如果说这个 res 值是一个对象的话，那么我们需要把获取到的 res 也转换成 reactive\n      // res 等于 target[key]\n      return isReadonly ? readonly(res) : reactive(res);\n    }\n\n    return res;\n  };\n}\n\nfunction createSetter() {\n  return function set(target, key, value, receiver) {\n    const result = Reflect.set(target, key, value, receiver);\n\n    // 在触发 set 的时候进行触发依赖\n    trigger(target, \"set\", key);\n\n    return result;\n  };\n}\n\nexport const readonlyHandlers = {\n  get: readonlyGet,\n  set(target, key) {\n    // readonly 的响应式对象不可以修改值\n    console.warn(\n      `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n      target\n    );\n    return true;\n  },\n};\n\nexport const mutableHandlers = {\n  get,\n  set,\n};\n\nexport const shallowReadonlyHandlers = {\n  get: shallowReadonlyGet,\n  set(target, key) {\n    // readonly 的响应式对象不可以修改值\n    console.warn(\n      `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n      target\n    );\n    return true;\n  },\n};\n","import {\n  mutableHandlers,\n  readonlyHandlers,\n  shallowReadonlyHandlers,\n} from \"./baseHandlers\";\n\nexport const reactiveMap = new WeakMap();\nexport const readonlyMap = new WeakMap();\nexport const shallowReadonlyMap = new WeakMap();\n\nexport const enum ReactiveFlags {\n  IS_REACTIVE = \"__v_isReactive\",\n  IS_READONLY = \"__v_isReadonly\",\n  RAW = \"__v_raw\",\n}\n\nexport function reactive(target) {\n  return createReactiveObject(target, reactiveMap, mutableHandlers);\n}\n\nexport function readonly(target) {\n  return createReactiveObject(target, readonlyMap, readonlyHandlers);\n}\n\nexport function shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    shallowReadonlyMap,\n    shallowReadonlyHandlers\n  );\n}\n\nexport function isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\n\nexport function isReadonly(value) {\n  return !!value[ReactiveFlags.IS_READONLY];\n}\n\nexport function isReactive(value) {\n  // 如果 value 是 proxy 的话\n  // 会触发 get 操作，而在 createGetter 里面会判断\n  // 如果 value 是普通对象的话\n  // 那么会返回 undefined ，那么就需要转换成布尔值\n  return !!value[ReactiveFlags.IS_REACTIVE];\n}\n\nexport function toRaw(value) {\n  // 如果 value 是 proxy 的话 ,那么直接返回就可以了\n  // 因为会触发 createGetter 内的逻辑\n  // 如果 value 是普通对象的话，\n  // 我们就应该返回普通对象\n  // 只要不是 proxy ，只要是得到了 undefined 的话，那么就一定是普通对象\n  // TODO 这里和源码里面实现的不一样，不确定后面会不会有问题\n  if (!value[ReactiveFlags.RAW]) {\n    return value;\n  }\n\n  return value[ReactiveFlags.RAW];\n}\n\nfunction createReactiveObject(target, proxyMap, baseHandlers) {\n  // 核心就是 proxy\n  // 目的是可以侦听到用户 get 或者 set 的动作\n\n  // 如果命中的话就直接返回就好了\n  // 使用缓存做的优化点\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n\n  const proxy = new Proxy(target, baseHandlers);\n\n  // 把创建好的 proxy 给存起来，\n  proxyMap.set(target, proxy);\n  return proxy;\n}\n","import { trackEffects, triggerEffects, isTracking } from \"./effect\";\nimport { createDep } from \"./dep\";\nimport { isObject, hasChanged } from \"@relaxed/shared\";\nimport { reactive } from \"./reactive\";\n\nexport class RefImpl {\n  private _rawValue: any;\n  private _value: any;\n  public dep;\n  public __v_isRef = true;\n\n  constructor(value) {\n    this._rawValue = value;\n    // 看看value 是不是一个对象，如果是一个对象的话\n    // 那么需要用 reactive 包裹一下\n    this._value = convert(value);\n    this.dep = createDep();\n  }\n\n  get value() {\n    // 收集依赖\n    trackRefValue(this);\n    return this._value;\n  }\n\n  set value(newValue) {\n    // 当新的值不等于老的值的话，\n    // 那么才需要触发依赖\n    if (hasChanged(newValue, this._rawValue)) {\n      // 更新值\n      this._value = convert(newValue);\n      this._rawValue = newValue;\n      // 触发依赖\n      triggerRefValue(this);\n    }\n  }\n}\n\nexport function ref(value) {\n  return createRef(value);\n}\n\nfunction convert(value) {\n  return isObject(value) ? reactive(value) : value;\n}\n\nfunction createRef(value) {\n  const refImpl = new RefImpl(value);\n\n  return refImpl;\n}\n\nexport function triggerRefValue(ref) {\n  triggerEffects(ref.dep);\n}\n\nexport function trackRefValue(ref) {\n  if (isTracking()) {\n    trackEffects(ref.dep);\n  }\n}\n\n// 这个函数的目的是\n// 帮助解构 ref\n// 比如在 template 中使用 ref 的时候，直接使用就可以了\n// 例如： const count = ref(0) -> 在 template 中使用的话 可以直接 count\n// 解决方案就是通过 proxy 来对 ref 做处理\n\nconst shallowUnwrapHandlers = {\n  get(target, key, receiver) {\n    // 如果里面是一个 ref 类型的话，那么就返回 .value\n    // 如果不是的话，那么直接返回value 就可以了\n    return unRef(Reflect.get(target, key, receiver));\n  },\n  set(target, key, value, receiver) {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      return (target[key].value = value);\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  },\n};\n\n// 这里没有处理 objectWithRefs 是 reactive 类型的时候\n// TODO reactive 里面如果有 ref 类型的 key 的话， 那么也是不需要调用 ref.value 的\n// （but 这个逻辑在 reactive 里面没有实现）\nexport function proxyRefs(objectWithRefs) {\n  return new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\n\n// 把 ref 里面的值拿到\nexport function unRef(ref) {\n  return isRef(ref) ? ref.value : ref;\n}\n\nexport function isRef(value) {\n  return !!value.__v_isRef;\n}\n","import { createDep } from \"./dep\";\nimport { ReactiveEffect } from \"./effect\";\nimport { trackRefValue, triggerRefValue } from \"./ref\";\n\nexport class ComputedRefImpl {\n  public dep: any;\n  public effect: ReactiveEffect;\n\n  private _dirty: boolean;\n  private _value\n\n  constructor(getter) {\n    this._dirty = true;\n    this.dep = createDep();\n    this.effect = new ReactiveEffect(getter, () => {\n      // scheduler\n      // 只要触发了这个函数说明响应式对象的值发生改变了\n      // 那么就解锁，后续在调用 get 的时候就会重新执行，所以会得到最新的值\n      if (this._dirty) return;\n\n      this._dirty = true;\n      triggerRefValue(this);\n    });\n  }\n\n  get value() {\n    // 收集依赖\n    trackRefValue(this);\n    // 锁上，只可以调用一次\n    // 当数据改变的时候才会解锁\n    // 这里就是缓存实现的核心\n    // 解锁是在 scheduler 里面做的\n    if (this._dirty) {\n      this._dirty = false;\n      // 这里执行 run 的话，就是执行用户传入的 fn\n      this._value = this.effect.run();\n    }\n\n    return this._value;\n  }\n}\n\nexport function computed(getter) {\n  return new ComputedRefImpl(getter);\n}\n"],"mappings":"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","names":["effect","dep","import_shared","isReadonly","get","set","import_shared","ref"]}