{"version":3,"sources":["../src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts"],"sourcesContent":["export {\n  reactive,\n  readonly,\n  // shallowReadonly,\n  // isReadonly,\n  // isReactive,\n  // isProxy,\n} from \"./reactive\";\n\n// export { ref, proxyRefs, unRef, isRef } from \"./ref\";\n\nexport { effect } from \"./effect\";\n\n// export { computed } from \"./computed\";\n","import { extend } from \"@relaxed/shared\";\n\nlet activeEffect;\nexport class ReactiveEffect {\n  deps = [];\n  activeStop = true;\n  // 可有可无\n  onStop?: () => void;\n  constructor(public fn, public scheduler?) {}\n  run() {\n    activeEffect = this;\n    return this.fn();\n  }\n  stop() {\n    if (this.activeStop) {\n      cleanupEffect(this);\n      if (this.onStop) {\n        this.onStop();\n      }\n      this.activeStop = false;\n    }\n  }\n}\nfunction cleanupEffect(effect) {\n  effect.deps.forEach((dep: any) => {\n    dep.delete(effect);\n  });\n}\nconst targetMap = new Map();\nexport function track(target, key) {\n  // target -> key -> dep\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    depsMap = new Map();\n    targetMap.set(target, depsMap);\n  }\n  let dep = depsMap.get(key);\n  if (!dep) {\n    dep = new Set();\n    depsMap.set(key, dep);\n  }\n  if (!activeEffect) return;\n  // 一开始没有 activeEffect\n  // console.log(activeEffect);\n  dep.add(activeEffect);\n  activeEffect.deps.push(dep);\n}\n\nexport function trigger(target, key) {\n  // 取出所有 收集到的依赖 进行遍历\n  let depsMap = targetMap.get(target);\n  let dep = depsMap.get(key);\n  for (const effect of dep) {\n    if (effect.scheduler) {\n      effect.scheduler();\n    } else {\n      effect.run();\n    }\n  }\n}\n\nexport function effect(fn, options: any = {}) {\n  const _effect = new ReactiveEffect(fn, options.scheduler);\n  extend(_effect, options);\n  console.log(_effect);\n  _effect.run();\n  const runner: any = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\n\nexport function stop(runner) {\n  runner.effect.stop();\n}\n\n// import { createDep } from \"./dep\";\n// import { extend } from \"@relaxed/shared\";\n\n// let activeEffect = void 0;\n// let shouldTrack = false;\n// const targetMap = new WeakMap();\n\n// // 用于依赖收集\n// export class ReactiveEffect {\n//   active = true;\n//   deps = [];\n//   public onStop?: () => void;\n//   constructor(public fn, public scheduler?) {\n//     console.log(\"创建 ReactiveEffect 对象\");\n//   }\n\n//   run() {\n//     console.log(\"run\");\n//     // 运行 run 的时候，可以控制 要不要执行后续收集依赖的一步\n//     // 目前来看的话，只要执行了 fn 那么就默认执行了收集依赖\n//     // 这里就需要控制了\n\n//     // 是不是收集依赖的变量\n\n//     // 执行 fn  但是不收集依赖\n//     if (!this.active) {\n//       return this.fn();\n//     }\n\n//     // 执行 fn  收集依赖\n//     // 可以开始收集依赖了\n//     shouldTrack = true;\n\n//     // 执行的时候给全局的 activeEffect 赋值\n//     // 利用全局属性来获取当前的 effect\n//     activeEffect = this as any;\n//     // 执行用户传入的 fn\n//     console.log(\"执行用户传入的 fn\");\n//     const result = this.fn();\n//     // 重置\n//     shouldTrack = false;\n//     activeEffect = undefined;\n\n//     return result;\n//   }\n\n//   stop() {\n//     if (this.active) {\n//       // 如果第一次执行 stop 后 active 就 false 了\n//       // 这是为了防止重复的调用，执行 stop 逻辑\n//       cleanupEffect(this);\n//       if (this.onStop) {\n//         this.onStop();\n//       }\n//       this.active = false;\n//     }\n//   }\n// }\n\n// function cleanupEffect(effect) {\n//   // 找到所有依赖这个 effect 的响应式对象\n//   // 从这些响应式对象里面把 effect 给删除掉\n//   effect.deps.forEach((dep) => {\n//     dep.delete(effect);\n//   });\n\n//   effect.deps.length = 0;\n// }\n\n// export function effect(fn, options = {}) {\n//   const _effect = new ReactiveEffect(fn);\n\n//   // 把用户传过来的值合并到 _effect 对象上去\n//   // 缺点就是不是显式的，看代码的时候并不知道有什么值\n//   extend(_effect, options);\n//   _effect.run();\n\n//   // 把 _effect.run 这个方法返回\n//   // 让用户可以自行选择调用的时机（调用 fn）\n//   const runner: any = _effect.run.bind(_effect);\n//   runner.effect = _effect;\n//   return runner;\n// }\n\n// export function stop(runner) {\n//   runner.effect.stop();\n// }\n\n// export function track(target, type, key) {\n//   if (!isTracking()) {\n//     return;\n//   }\n//   console.log(`触发 track -> target: ${target} type:${type} key:${key}`);\n//   // 1. 先基于 target 找到对应的 dep\n//   // 如果是第一次的话，那么就需要初始化\n//   let depsMap = targetMap.get(target);\n//   if (!depsMap) {\n//     // 初始化 depsMap 的逻辑\n//     depsMap = new Map();\n//     targetMap.set(target, depsMap);\n//   }\n\n//   let dep = depsMap.get(key);\n\n//   if (!dep) {\n//     dep = createDep();\n\n//     depsMap.set(key, dep);\n//   }\n\n//   trackEffects(dep);\n// }\n\n// export function trackEffects(dep) {\n//   // 用 dep 来存放所有的 effect\n\n//   // TODO\n//   // 这里是一个优化点\n//   // 先看看这个依赖是不是已经收集了，\n//   // 已经收集的话，那么就不需要在收集一次了\n//   // 可能会影响 code path change 的情况\n//   // 需要每次都 cleanupEffect\n//   // shouldTrack = !dep.has(activeEffect!);\n//   if (!dep.has(activeEffect)) {\n//     dep.add(activeEffect);\n//     (activeEffect as any).deps.push(dep);\n//   }\n// }\n\n// export function trigger(target, type, key) {\n//   // 1. 先收集所有的 dep 放到 deps 里面，\n//   // 后面会统一处理\n//   let deps: Array<any> = [];\n//   // dep\n\n//   const depsMap = targetMap.get(target);\n\n//   if (!depsMap) return;\n\n//   // 暂时只实现了 GET 类型\n//   // get 类型只需要取出来就可以\n//   const dep = depsMap.get(key);\n\n//   // 最后收集到 deps 内\n//   deps.push(dep);\n\n//   const effects: Array<any> = [];\n//   deps.forEach((dep) => {\n//     // 这里解构 dep 得到的是 dep 内部存储的 effect\n//     effects.push(...dep);\n//   });\n//   // 这里的目的是只有一个 dep ，这个dep 里面包含所有的 effect\n//   // 这里的目前应该是为了 triggerEffects 这个函数的复用\n//   triggerEffects(createDep(effects));\n// }\n\n// export function isTracking() {\n//   return shouldTrack && activeEffect !== undefined;\n// }\n\n// export function triggerEffects(dep) {\n//   // 执行收集到的所有的 effect 的 run 方法\n//   for (const effect of dep) {\n//     if (effect.scheduler) {\n//       // scheduler 可以让用户自己选择调用的时机\n//       // 这样就可以灵活的控制调用了\n//       // 在 runtime-core 中，就是使用了 scheduler 实现了在 next ticker 中调用的逻辑\n//       effect.scheduler();\n//     } else {\n//       effect.run();\n//     }\n//   }\n// }\n","import { track, trigger } from \"./effect\";\n\n// 缓存一个getter & setter\nconst get = createGetter();\nconst set = createSetter()\nconst readonlyGet = createGetter(true)\n// 高阶函数判断逻辑\nexport function createGetter(isReadonly = false) {\n  return function get(target, key) {\n    const res = Reflect.get(target, key);\n    // track\n    if (!isReadonly) {\n      track(target, key);\n    }\n    // console.log(\"触发get\");\n    return res;\n  };\n}\n\nexport function createSetter() {\n  return function set(target, key, value) {\n    const res = Reflect.set(target, key, value);\n    // trigger\n    trigger(target, key);\n    // console.log(\"触发set\");\n    return res;\n  };\n}\n\nexport const mutableHandlers = {\n  get,\n  set,\n};\nexport const readonlyHandlers = {\n  get: readonlyGet,\n  set(target, key, value) {\n    console.warn(`${key} is not change ${target} is read-only`);\n    return true;\n  },\n};\n\n// import { ReactiveEffect, track, trigger } from \"./effect\";\n// import {\n//   reactive,\n//   ReactiveFlags,\n//   reactiveMap,\n//   readonly,\n//   readonlyMap,\n//   shallowReadonlyMap,\n// } from \"./reactive\";\n// import { isObject } from \"@relaxed/shared\";\n\n// const get = createGetter();\n// const set = createSetter();\n// const readonlyGet = createGetter(true);\n// const shallowReadonlyGet = createGetter(true, true);\n\n// function createGetter(isReadonly = false, shallow = false) {\n//   return function get(target, key, receiver) {\n//     const isExistInReactiveMap = () =>\n//       key === ReactiveFlags.RAW && receiver === reactiveMap.get(target);\n\n//     const isExistInReadonlyMap = () =>\n//       key === ReactiveFlags.RAW && receiver === readonlyMap.get(target);\n\n//     const isExistInShallowReadonlyMap = () =>\n//       key === ReactiveFlags.RAW && receiver === shallowReadonlyMap.get(target);\n\n//     if (key === ReactiveFlags.IS_REACTIVE) {\n//       return !isReadonly;\n//     } else if (key === ReactiveFlags.IS_READONLY) {\n//       return isReadonly;\n//     } else if (\n//       isExistInReactiveMap() ||\n//       isExistInReadonlyMap() ||\n//       isExistInShallowReadonlyMap()\n//     ) {\n//       return target;\n//     }\n\n//     const res = Reflect.get(target, key, receiver);\n\n//     // 问题：为什么是 readonly 的时候不做依赖收集呢\n//     // readonly 的话，是不可以被 set 的， 那不可以被 set 就意味着不会触发 trigger\n//     // 所有就没有收集依赖的必要了\n\n//     if (!isReadonly) {\n//       // 在触发 get 的时候进行依赖收集\n//       track(target, \"get\", key);\n//     }\n\n//     if (shallow) {\n//       return res;\n//     }\n\n//     if (isObject(res)) {\n//       // 把内部所有的是 object 的值都用 reactive 包裹，变成响应式对象\n//       // 如果说这个 res 值是一个对象的话，那么我们需要把获取到的 res 也转换成 reactive\n//       // res 等于 target[key]\n//       return isReadonly ? readonly(res) : reactive(res);\n//     }\n\n//     return res;\n//   };\n// }\n\n// function createSetter() {\n//   return function set(target, key, value, receiver) {\n//     const result = Reflect.set(target, key, value, receiver);\n\n//     // 在触发 set 的时候进行触发依赖\n//     trigger(target, \"set\", key);\n\n//     return result;\n//   };\n// }\n\n// export const readonlyHandlers = {\n//   get: readonlyGet,\n//   set(target, key) {\n//     // readonly 的响应式对象不可以修改值\n//     console.warn(\n//       `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n//       target\n//     );\n//     return true;\n//   },\n// };\n\n// export const mutableHandlers = {\n//   get,\n//   set,\n// };\n\n// export const shallowReadonlyHandlers = {\n//   get: shallowReadonlyGet,\n//   set(target, key) {\n//     // readonly 的响应式对象不可以修改值\n//     console.warn(\n//       `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n//       target\n//     );\n//     return true;\n//   },\n// };\n","import { mutableHandlers, readonlyHandlers } from \"./baseHandlers\";\n// true  false 判断是否是 readonly\nexport function reactive(raw) {\n  return createActiveObject(raw, mutableHandlers);\n}\n\nexport function readonly(raw) {\n  return createActiveObject(raw, readonlyHandlers);\n}\n\nfunction createActiveObject(raw, Handlers) {\n  return new Proxy(raw, Handlers);\n}\n\n// import {\n//   mutableHandlers,\n//   readonlyHandlers,\n//   shallowReadonlyHandlers,\n// } from \"./baseHandlers\";\n\n// export const reactiveMap = new WeakMap();\n// export const readonlyMap = new WeakMap();\n// export const shallowReadonlyMap = new WeakMap();\n\n// export const enum ReactiveFlags {\n//   IS_REACTIVE = \"__v_isReactive\",\n//   IS_READONLY = \"__v_isReadonly\",\n//   RAW = \"__v_raw\",\n// }\n\n// export function reactive(target) {\n//   return createReactiveObject(target, reactiveMap, mutableHandlers);\n// }\n\n// export function readonly(target) {\n//   return createReactiveObject(target, readonlyMap, readonlyHandlers);\n// }\n\n// export function shallowReadonly(target) {\n//   return createReactiveObject(\n//     target,\n//     shallowReadonlyMap,\n//     shallowReadonlyHandlers\n//   );\n// }\n\n// export function isProxy(value) {\n//   return isReactive(value) || isReadonly(value);\n// }\n\n// export function isReadonly(value) {\n//   return !!value[ReactiveFlags.IS_READONLY];\n// }\n\n// export function isReactive(value) {\n//   // 如果 value 是 proxy 的话\n//   // 会触发 get 操作，而在 createGetter 里面会判断\n//   // 如果 value 是普通对象的话\n//   // 那么会返回 undefined ，那么就需要转换成布尔值\n//   return !!value[ReactiveFlags.IS_REACTIVE];\n// }\n\n// export function toRaw(value) {\n//   // 如果 value 是 proxy 的话 ,那么直接返回就可以了\n//   // 因为会触发 createGetter 内的逻辑\n//   // 如果 value 是普通对象的话，\n//   // 我们就应该返回普通对象\n//   // 只要不是 proxy ，只要是得到了 undefined 的话，那么就一定是普通对象\n//   // TODO 这里和源码里面实现的不一样，不确定后面会不会有问题\n//   if (!value[ReactiveFlags.RAW]) {\n//     return value;\n//   }\n\n//   return value[ReactiveFlags.RAW];\n// }\n\n// function createReactiveObject(target, proxyMap, baseHandlers) {\n//   // 核心就是 proxy\n//   // 目的是可以侦听到用户 get 或者 set 的动作\n\n//   // 如果命中的话就直接返回就好了\n//   // 使用缓存做的优化点\n//   const existingProxy = proxyMap.get(target);\n//   if (existingProxy) {\n//     return existingProxy;\n//   }\n\n//   const proxy = new Proxy(target, baseHandlers);\n\n//   // 把创建好的 proxy 给存起来，\n//   proxyMap.set(target, proxy);\n//   return proxy;\n// }\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,oBAAuB;AAEvB,IAAI;AACG,IAAM,iBAAN,MAAqB;AAAA,EAK1B,YAAmB,IAAW,WAAY;AAAvB;AAAW;AAAA,EAAa;AAAA,EAJ3C,OAAO,CAAC;AAAA,EACR,aAAa;AAAA,EAEb;AAAA,EAEA,MAAM;AACJ,mBAAe;AACf,WAAO,KAAK,GAAG;AAAA,EACjB;AAAA,EACA,OAAO;AACL,QAAI,KAAK,YAAY;AACnB,oBAAc,IAAI;AAClB,UAAI,KAAK,QAAQ;AACf,aAAK,OAAO;AAAA,MACd;AACA,WAAK,aAAa;AAAA,IACpB;AAAA,EACF;AACF;AACA,SAAS,cAAcA,SAAQ;AAC7B,EAAAA,QAAO,KAAK,QAAQ,CAAC,QAAa;AAChC,QAAI,OAAOA,OAAM;AAAA,EACnB,CAAC;AACH;AACA,IAAM,YAAY,oBAAI,IAAI;AACnB,SAAS,MAAM,QAAQ,KAAK;AAEjC,MAAI,UAAU,UAAU,IAAI,MAAM;AAClC,MAAI,CAAC,SAAS;AACZ,cAAU,oBAAI,IAAI;AAClB,cAAU,IAAI,QAAQ,OAAO;AAAA,EAC/B;AACA,MAAI,MAAM,QAAQ,IAAI,GAAG;AACzB,MAAI,CAAC,KAAK;AACR,UAAM,oBAAI,IAAI;AACd,YAAQ,IAAI,KAAK,GAAG;AAAA,EACtB;AACA,MAAI,CAAC;AAAc;AAGnB,MAAI,IAAI,YAAY;AACpB,eAAa,KAAK,KAAK,GAAG;AAC5B;AAEO,SAAS,QAAQ,QAAQ,KAAK;AAEnC,MAAI,UAAU,UAAU,IAAI,MAAM;AAClC,MAAI,MAAM,QAAQ,IAAI,GAAG;AACzB,aAAWA,WAAU,KAAK;AACxB,QAAIA,QAAO,WAAW;AACpB,MAAAA,QAAO,UAAU;AAAA,IACnB,OAAO;AACL,MAAAA,QAAO,IAAI;AAAA,IACb;AAAA,EACF;AACF;AAEO,SAAS,OAAO,IAAI,UAAe,CAAC,GAAG;AAC5C,QAAM,UAAU,IAAI,eAAe,IAAI,QAAQ,SAAS;AACxD,4BAAO,SAAS,OAAO;AACvB,UAAQ,IAAI,OAAO;AACnB,UAAQ,IAAI;AACZ,QAAM,SAAc,QAAQ,IAAI,KAAK,OAAO;AAC5C,SAAO,SAAS;AAChB,SAAO;AACT;;;AClEA,IAAM,MAAM,aAAa;AACzB,IAAM,MAAM,aAAa;AACzB,IAAM,cAAc,aAAa,IAAI;AAE9B,SAAS,aAAa,aAAa,OAAO;AAC/C,SAAO,SAASC,KAAI,QAAQ,KAAK;AAC/B,UAAM,MAAM,QAAQ,IAAI,QAAQ,GAAG;AAEnC,QAAI,CAAC,YAAY;AACf,YAAM,QAAQ,GAAG;AAAA,IACnB;AAEA,WAAO;AAAA,EACT;AACF;AAEO,SAAS,eAAe;AAC7B,SAAO,SAASC,KAAI,QAAQ,KAAK,OAAO;AACtC,UAAM,MAAM,QAAQ,IAAI,QAAQ,KAAK,KAAK;AAE1C,YAAQ,QAAQ,GAAG;AAEnB,WAAO;AAAA,EACT;AACF;AAEO,IAAM,kBAAkB;AAAA,EAC7B;AAAA,EACA;AACF;AACO,IAAM,mBAAmB;AAAA,EAC9B,KAAK;AAAA,EACL,IAAI,QAAQ,KAAK,OAAO;AACtB,YAAQ,KAAK,GAAG,qBAAqB,qBAAqB;AAC1D,WAAO;AAAA,EACT;AACF;;;ACrCO,SAAS,SAAS,KAAK;AAC5B,SAAO,mBAAmB,KAAK,eAAe;AAChD;AAEO,SAAS,SAAS,KAAK;AAC5B,SAAO,mBAAmB,KAAK,gBAAgB;AACjD;AAEA,SAAS,mBAAmB,KAAK,UAAU;AACzC,SAAO,IAAI,MAAM,KAAK,QAAQ;AAChC;","names":["effect","get","set"]}