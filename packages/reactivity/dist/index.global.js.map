{"version":3,"sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts"],"sourcesContent":["export * from \"../src/shapeFlags\";\nexport * from \"../src/toDisplayString\";\n\nexport const isObject = (val) => {\n  return val !== null && typeof val === \"object\";\n};\n\nexport const isString = (val) => typeof val === \"string\";\n\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n * 把烤肉串命名方式转换成驼峰命名方式\n */\nexport const camelize = (str: string): string => {\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : \"\"));\n};\n\nexport const extend = Object.assign;\n\n// 必须是 on+一个大写字母的格式开头\nexport const isOn = (key) => /^on[A-Z]/.test(key);\n\nexport function hasChanged(value, oldValue) {\n  return !Object.is(value, oldValue);\n}\n\nexport function hasOwn(val, key) {\n  return Object.prototype.hasOwnProperty.call(val, key);\n}\n\n/**\n * @private\n * 首字母大写\n */\nexport const capitalize = (str: string) =>\n  str.charAt(0).toUpperCase() + str.slice(1);\n\n/**\n * @private\n * 添加 on 前缀，并且首字母大写\n */\nexport const toHandlerKey = (str: string) =>\n  str ? `on${capitalize(str)}` : ``;\n\n// 用来匹配 kebab-case 的情况\n// 比如 onTest-event 可以匹配到 T\n// 然后取到 T 在前面加一个 - 就可以\n// \\BT 就可以匹配到 T 前面是字母的位置\nconst hyphenateRE = /\\B([A-Z])/g;\n/**\n * @private\n */\nexport const hyphenate = (str: string) =>\n  str.replace(hyphenateRE, \"-$1\").toLowerCase();\n","import { extend } from \"@relaxed/shared\";\n\nlet activeEffect;\nlet shouldTrack;\nexport class ReactiveEffect {\n  deps = [];\n  activeStop = true;\n  // 可有可无\n  onStop?: () => void;\n  constructor(public fn, public scheduler?) {}\n  run() {\n    // 1. 会收集依赖\n    if (!this.activeStop) {\n      return this.fn();\n    }\n    shouldTrack = true;\n    activeEffect = this;\n    const res = this.fn();\n    shouldTrack = false;\n    return res;\n  }\n  stop() {\n    if (this.activeStop) {\n      cleanupEffect(this);\n      if (this.onStop) {\n        this.onStop();\n      }\n      this.activeStop = false;\n    }\n  }\n}\nfunction cleanupEffect(effect) {\n  effect.deps.forEach((dep: any) => {\n    dep.delete(effect);\n  });\n  effect.deps.length = 0;\n}\nconst targetMap = new Map();\nexport function track(target, key) {\n  // 一开始没有 activeEffect\n  if (!activeEffect) return;\n  // 防止 同时触发 get 和 set 操作 他还是会收集到依赖 stop 会失效\n  if (!shouldTrack) return;\n  // target -> key -> dep\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    depsMap = new Map();\n    targetMap.set(target, depsMap);\n  }\n  let dep = depsMap.get(key);\n  if (!dep) {\n    dep = new Set();\n    depsMap.set(key, dep);\n  }\n  dep.add(activeEffect);\n  activeEffect.deps.push(dep);\n}\n\nexport function trigger(target, key) {\n  // 取出所有 收集到的依赖 进行遍历\n  let depsMap = targetMap.get(target);\n  let dep = depsMap.get(key);\n  for (const effect of dep) {\n    if (effect.scheduler) {\n      effect.scheduler();\n    } else {\n      effect.run();\n    }\n  }\n}\n\nexport function effect(fn, options: any = {}) {\n  const _effect = new ReactiveEffect(fn, options.scheduler);\n  extend(_effect, options);\n  console.log(_effect);\n  _effect.run();\n  const runner: any = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\n\nexport function stop(runner) {\n  runner.effect.stop();\n}\n\n// import { createDep } from \"./dep\";\n// import { extend } from \"@relaxed/shared\";\n\n// let activeEffect = void 0;\n// let shouldTrack = false;\n// const targetMap = new WeakMap();\n\n// // 用于依赖收集\n// export class ReactiveEffect {\n//   active = true;\n//   deps = [];\n//   public onStop?: () => void;\n//   constructor(public fn, public scheduler?) {\n//     console.log(\"创建 ReactiveEffect 对象\");\n//   }\n\n//   run() {\n//     console.log(\"run\");\n//     // 运行 run 的时候，可以控制 要不要执行后续收集依赖的一步\n//     // 目前来看的话，只要执行了 fn 那么就默认执行了收集依赖\n//     // 这里就需要控制了\n\n//     // 是不是收集依赖的变量\n\n//     // 执行 fn  但是不收集依赖\n//     if (!this.active) {\n//       return this.fn();\n//     }\n\n//     // 执行 fn  收集依赖\n//     // 可以开始收集依赖了\n//     shouldTrack = true;\n\n//     // 执行的时候给全局的 activeEffect 赋值\n//     // 利用全局属性来获取当前的 effect\n//     activeEffect = this as any;\n//     // 执行用户传入的 fn\n//     console.log(\"执行用户传入的 fn\");\n//     const result = this.fn();\n//     // 重置\n//     shouldTrack = false;\n//     activeEffect = undefined;\n\n//     return result;\n//   }\n\n//   stop() {\n//     if (this.active) {\n//       // 如果第一次执行 stop 后 active 就 false 了\n//       // 这是为了防止重复的调用，执行 stop 逻辑\n//       cleanupEffect(this);\n//       if (this.onStop) {\n//         this.onStop();\n//       }\n//       this.active = false;\n//     }\n//   }\n// }\n\n// function cleanupEffect(effect) {\n//   // 找到所有依赖这个 effect 的响应式对象\n//   // 从这些响应式对象里面把 effect 给删除掉\n//   effect.deps.forEach((dep) => {\n//     dep.delete(effect);\n//   });\n\n//   effect.deps.length = 0;\n// }\n\n// export function effect(fn, options = {}) {\n//   const _effect = new ReactiveEffect(fn);\n\n//   // 把用户传过来的值合并到 _effect 对象上去\n//   // 缺点就是不是显式的，看代码的时候并不知道有什么值\n//   extend(_effect, options);\n//   _effect.run();\n\n//   // 把 _effect.run 这个方法返回\n//   // 让用户可以自行选择调用的时机（调用 fn）\n//   const runner: any = _effect.run.bind(_effect);\n//   runner.effect = _effect;\n//   return runner;\n// }\n\n// export function stop(runner) {\n//   runner.effect.stop();\n// }\n\n// export function track(target, type, key) {\n//   if (!isTracking()) {\n//     return;\n//   }\n//   console.log(`触发 track -> target: ${target} type:${type} key:${key}`);\n//   // 1. 先基于 target 找到对应的 dep\n//   // 如果是第一次的话，那么就需要初始化\n//   let depsMap = targetMap.get(target);\n//   if (!depsMap) {\n//     // 初始化 depsMap 的逻辑\n//     depsMap = new Map();\n//     targetMap.set(target, depsMap);\n//   }\n\n//   let dep = depsMap.get(key);\n\n//   if (!dep) {\n//     dep = createDep();\n\n//     depsMap.set(key, dep);\n//   }\n\n//   trackEffects(dep);\n// }\n\n// export function trackEffects(dep) {\n//   // 用 dep 来存放所有的 effect\n\n//   // TODO\n//   // 这里是一个优化点\n//   // 先看看这个依赖是不是已经收集了，\n//   // 已经收集的话，那么就不需要在收集一次了\n//   // 可能会影响 code path change 的情况\n//   // 需要每次都 cleanupEffect\n//   // shouldTrack = !dep.has(activeEffect!);\n//   if (!dep.has(activeEffect)) {\n//     dep.add(activeEffect);\n//     (activeEffect as any).deps.push(dep);\n//   }\n// }\n\n// export function trigger(target, type, key) {\n//   // 1. 先收集所有的 dep 放到 deps 里面，\n//   // 后面会统一处理\n//   let deps: Array<any> = [];\n//   // dep\n\n//   const depsMap = targetMap.get(target);\n\n//   if (!depsMap) return;\n\n//   // 暂时只实现了 GET 类型\n//   // get 类型只需要取出来就可以\n//   const dep = depsMap.get(key);\n\n//   // 最后收集到 deps 内\n//   deps.push(dep);\n\n//   const effects: Array<any> = [];\n//   deps.forEach((dep) => {\n//     // 这里解构 dep 得到的是 dep 内部存储的 effect\n//     effects.push(...dep);\n//   });\n//   // 这里的目的是只有一个 dep ，这个dep 里面包含所有的 effect\n//   // 这里的目前应该是为了 triggerEffects 这个函数的复用\n//   triggerEffects(createDep(effects));\n// }\n\n// export function isTracking() {\n//   return shouldTrack && activeEffect !== undefined;\n// }\n\n// export function triggerEffects(dep) {\n//   // 执行收集到的所有的 effect 的 run 方法\n//   for (const effect of dep) {\n//     if (effect.scheduler) {\n//       // scheduler 可以让用户自己选择调用的时机\n//       // 这样就可以灵活的控制调用了\n//       // 在 runtime-core 中，就是使用了 scheduler 实现了在 next ticker 中调用的逻辑\n//       effect.scheduler();\n//     } else {\n//       effect.run();\n//     }\n//   }\n// }\n","import { track, trigger } from \"./effect\";\nimport { ReactiveFlags } from \"./reactive\";\n\n// 缓存一个getter & setter\nconst get = createGetter();\nconst set = createSetter()\nconst readonlyGet = createGetter(true)\n// 高阶函数判断逻辑\nexport function createGetter(isReadonly = false) {\n  return function get(target, key) {\n    const res = Reflect.get(target, key);\n    // track\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly\n    }\n    if (!isReadonly) {\n      track(target, key);\n    }\n    // console.log(\"触发get\");\n    return res;\n  };\n}\n\nexport function createSetter() {\n  return function set(target, key, value) {\n    const res = Reflect.set(target, key, value);\n    // trigger\n    trigger(target, key);\n    // console.log(\"触发set\");\n    return res;\n  };\n}\n\nexport const mutableHandlers = {\n  get,\n  set,\n};\nexport const readonlyHandlers = {\n  get: readonlyGet,\n  set(target, key, value) {\n    console.warn(`${key} is not change ${target} is read-only`);\n    return true;\n  },\n};\n\n// import { ReactiveEffect, track, trigger } from \"./effect\";\n// import {\n//   reactive,\n//   ReactiveFlags,\n//   reactiveMap,\n//   readonly,\n//   readonlyMap,\n//   shallowReadonlyMap,\n// } from \"./reactive\";\n// import { isObject } from \"@relaxed/shared\";\n\n// const get = createGetter();\n// const set = createSetter();\n// const readonlyGet = createGetter(true);\n// const shallowReadonlyGet = createGetter(true, true);\n\n// function createGetter(isReadonly = false, shallow = false) {\n//   return function get(target, key, receiver) {\n//     const isExistInReactiveMap = () =>\n//       key === ReactiveFlags.RAW && receiver === reactiveMap.get(target);\n\n//     const isExistInReadonlyMap = () =>\n//       key === ReactiveFlags.RAW && receiver === readonlyMap.get(target);\n\n//     const isExistInShallowReadonlyMap = () =>\n//       key === ReactiveFlags.RAW && receiver === shallowReadonlyMap.get(target);\n\n//     if (key === ReactiveFlags.IS_REACTIVE) {\n//       return !isReadonly;\n//     } else if (key === ReactiveFlags.IS_READONLY) {\n//       return isReadonly;\n//     } else if (\n//       isExistInReactiveMap() ||\n//       isExistInReadonlyMap() ||\n//       isExistInShallowReadonlyMap()\n//     ) {\n//       return target;\n//     }\n\n//     const res = Reflect.get(target, key, receiver);\n\n//     // 问题：为什么是 readonly 的时候不做依赖收集呢\n//     // readonly 的话，是不可以被 set 的， 那不可以被 set 就意味着不会触发 trigger\n//     // 所有就没有收集依赖的必要了\n\n//     if (!isReadonly) {\n//       // 在触发 get 的时候进行依赖收集\n//       track(target, \"get\", key);\n//     }\n\n//     if (shallow) {\n//       return res;\n//     }\n\n//     if (isObject(res)) {\n//       // 把内部所有的是 object 的值都用 reactive 包裹，变成响应式对象\n//       // 如果说这个 res 值是一个对象的话，那么我们需要把获取到的 res 也转换成 reactive\n//       // res 等于 target[key]\n//       return isReadonly ? readonly(res) : reactive(res);\n//     }\n\n//     return res;\n//   };\n// }\n\n// function createSetter() {\n//   return function set(target, key, value, receiver) {\n//     const result = Reflect.set(target, key, value, receiver);\n\n//     // 在触发 set 的时候进行触发依赖\n//     trigger(target, \"set\", key);\n\n//     return result;\n//   };\n// }\n\n// export const readonlyHandlers = {\n//   get: readonlyGet,\n//   set(target, key) {\n//     // readonly 的响应式对象不可以修改值\n//     console.warn(\n//       `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n//       target\n//     );\n//     return true;\n//   },\n// };\n\n// export const mutableHandlers = {\n//   get,\n//   set,\n// };\n\n// export const shallowReadonlyHandlers = {\n//   get: shallowReadonlyGet,\n//   set(target, key) {\n//     // readonly 的响应式对象不可以修改值\n//     console.warn(\n//       `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n//       target\n//     );\n//     return true;\n//   },\n// };\n","import { mutableHandlers, readonlyHandlers } from \"./baseHandlers\";\n\n// 是一个reactive\nexport const enum ReactiveFlags {\n  IS_REACTIVE = \"_v_isReactive\",\n  IS_READONLY = \"_v_isReadonly\",\n}\n// true  false 判断是否是 readonly\nexport function reactive(raw) {\n  return createActiveObject(raw, mutableHandlers);\n}\n\nexport function readonly(raw) {\n  return createActiveObject(raw, readonlyHandlers);\n}\n\nexport function isReactive(raw) {\n  // 如果是原始对象没有 proxy 代理 是undefined 转成 boolean\n  return !!raw[ReactiveFlags.IS_REACTIVE];\n}\nexport function isReadonly(raw) {\n  return !!raw[ReactiveFlags.IS_READONLY];\n}\n\nfunction createActiveObject(raw, Handlers) {\n  return new Proxy(raw, Handlers);\n}\n\n// import {\n//   mutableHandlers,\n//   readonlyHandlers,\n//   shallowReadonlyHandlers,\n// } from \"./baseHandlers\";\n\n// export const reactiveMap = new WeakMap();\n// export const readonlyMap = new WeakMap();\n// export const shallowReadonlyMap = new WeakMap();\n\n// export const enum ReactiveFlags {\n//   IS_REACTIVE = \"__v_isReactive\",\n//   IS_READONLY = \"__v_isReadonly\",\n//   RAW = \"__v_raw\",\n// }\n\n// export function reactive(target) {\n//   return createReactiveObject(target, reactiveMap, mutableHandlers);\n// }\n\n// export function readonly(target) {\n//   return createReactiveObject(target, readonlyMap, readonlyHandlers);\n// }\n\n// export function shallowReadonly(target) {\n//   return createReactiveObject(\n//     target,\n//     shallowReadonlyMap,\n//     shallowReadonlyHandlers\n//   );\n// }\n\n// export function isProxy(value) {\n//   return isReactive(value) || isReadonly(value);\n// }\n\n// export function isReadonly(value) {\n//   return !!value[ReactiveFlags.IS_READONLY];\n// }\n\n// export function isReactive(value) {\n//   // 如果 value 是 proxy 的话\n//   // 会触发 get 操作，而在 createGetter 里面会判断\n//   // 如果 value 是普通对象的话\n//   // 那么会返回 undefined ，那么就需要转换成布尔值\n//   return !!value[ReactiveFlags.IS_REACTIVE];\n// }\n\n// export function toRaw(value) {\n//   // 如果 value 是 proxy 的话 ,那么直接返回就可以了\n//   // 因为会触发 createGetter 内的逻辑\n//   // 如果 value 是普通对象的话，\n//   // 我们就应该返回普通对象\n//   // 只要不是 proxy ，只要是得到了 undefined 的话，那么就一定是普通对象\n//   // TODO 这里和源码里面实现的不一样，不确定后面会不会有问题\n//   if (!value[ReactiveFlags.RAW]) {\n//     return value;\n//   }\n\n//   return value[ReactiveFlags.RAW];\n// }\n\n// function createReactiveObject(target, proxyMap, baseHandlers) {\n//   // 核心就是 proxy\n//   // 目的是可以侦听到用户 get 或者 set 的动作\n\n//   // 如果命中的话就直接返回就好了\n//   // 使用缓存做的优化点\n//   const existingProxy = proxyMap.get(target);\n//   if (existingProxy) {\n//     return existingProxy;\n//   }\n\n//   const proxy = new Proxy(target, baseHandlers);\n\n//   // 把创建好的 proxy 给存起来，\n//   proxyMap.set(target, proxy);\n//   return proxy;\n// }\n"],"mappings":"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","names":["effect","get","set"]}