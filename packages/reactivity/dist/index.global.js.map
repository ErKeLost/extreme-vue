{"version":3,"sources":["../../shared/src/index.ts","../src/effect.ts","../src/reactive.ts"],"sourcesContent":["export * from \"../src/shapeFlags\";\nexport * from \"../src/toDisplayString\";\n\nexport const isObject = (val) => {\n  return val !== null && typeof val === \"object\";\n};\n\nexport const isString = (val) => typeof val === \"string\";\n\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n * 把烤肉串命名方式转换成驼峰命名方式\n */\nexport const camelize = (str: string): string => {\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : \"\"));\n};\n\nexport const extend = Object.assign;\n\n// 必须是 on+一个大写字母的格式开头\nexport const isOn = (key) => /^on[A-Z]/.test(key);\n\nexport function hasChanged(value, oldValue) {\n  return !Object.is(value, oldValue);\n}\n\nexport function hasOwn(val, key) {\n  return Object.prototype.hasOwnProperty.call(val, key);\n}\n\n/**\n * @private\n * 首字母大写\n */\nexport const capitalize = (str: string) =>\n  str.charAt(0).toUpperCase() + str.slice(1);\n\n/**\n * @private\n * 添加 on 前缀，并且首字母大写\n */\nexport const toHandlerKey = (str: string) =>\n  str ? `on${capitalize(str)}` : ``;\n\n// 用来匹配 kebab-case 的情况\n// 比如 onTest-event 可以匹配到 T\n// 然后取到 T 在前面加一个 - 就可以\n// \\BT 就可以匹配到 T 前面是字母的位置\nconst hyphenateRE = /\\B([A-Z])/g;\n/**\n * @private\n */\nexport const hyphenate = (str: string) =>\n  str.replace(hyphenateRE, \"-$1\").toLowerCase();\n","import { extend } from \"@relaxed/shared\";\n\nlet activeEffect;\nexport class ReactiveEffect {\n  deps = [];\n  activeStop = true;\n  // 可有可无\n  onStop?: () => void;\n  constructor(public fn, public scheduler?) {}\n  run() {\n    activeEffect = this;\n    return this.fn();\n  }\n  stop() {\n    if (this.activeStop) {\n      cleanupEffect(this);\n      if (this.onStop) {\n        this.onStop();\n      }\n      this.activeStop = false;\n    }\n  }\n}\nfunction cleanupEffect(effect) {\n  effect.deps.forEach((dep: any) => {\n    dep.delete(effect);\n  });\n}\nconst targetMap = new Map();\nexport function track(target, key) {\n  // target -> key -> dep\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    depsMap = new Map();\n    targetMap.set(target, depsMap);\n  }\n  let dep = depsMap.get(key);\n  if (!dep) {\n    dep = new Set();\n    depsMap.set(key, dep);\n  }\n  if (!activeEffect) return;\n  // 一开始没有 activeEffect\n  // console.log(activeEffect);\n  dep.add(activeEffect);\n  activeEffect.deps.push(dep);\n}\n\nexport function trigger(target, key) {\n  // 取出所有 收集到的依赖 进行遍历\n  let depsMap = targetMap.get(target);\n  let dep = depsMap.get(key);\n  for (const effect of dep) {\n    if (effect.scheduler) {\n      effect.scheduler();\n    } else {\n      effect.run();\n    }\n  }\n}\n\nexport function effect(fn, options: any = {}) {\n  const _effect = new ReactiveEffect(fn, options.scheduler);\n  extend(_effect, options);\n  console.log(_effect);\n  _effect.run();\n  const runner: any = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\n\nexport function stop(runner) {\n  runner.effect.stop();\n}\n\n// import { createDep } from \"./dep\";\n// import { extend } from \"@relaxed/shared\";\n\n// let activeEffect = void 0;\n// let shouldTrack = false;\n// const targetMap = new WeakMap();\n\n// // 用于依赖收集\n// export class ReactiveEffect {\n//   active = true;\n//   deps = [];\n//   public onStop?: () => void;\n//   constructor(public fn, public scheduler?) {\n//     console.log(\"创建 ReactiveEffect 对象\");\n//   }\n\n//   run() {\n//     console.log(\"run\");\n//     // 运行 run 的时候，可以控制 要不要执行后续收集依赖的一步\n//     // 目前来看的话，只要执行了 fn 那么就默认执行了收集依赖\n//     // 这里就需要控制了\n\n//     // 是不是收集依赖的变量\n\n//     // 执行 fn  但是不收集依赖\n//     if (!this.active) {\n//       return this.fn();\n//     }\n\n//     // 执行 fn  收集依赖\n//     // 可以开始收集依赖了\n//     shouldTrack = true;\n\n//     // 执行的时候给全局的 activeEffect 赋值\n//     // 利用全局属性来获取当前的 effect\n//     activeEffect = this as any;\n//     // 执行用户传入的 fn\n//     console.log(\"执行用户传入的 fn\");\n//     const result = this.fn();\n//     // 重置\n//     shouldTrack = false;\n//     activeEffect = undefined;\n\n//     return result;\n//   }\n\n//   stop() {\n//     if (this.active) {\n//       // 如果第一次执行 stop 后 active 就 false 了\n//       // 这是为了防止重复的调用，执行 stop 逻辑\n//       cleanupEffect(this);\n//       if (this.onStop) {\n//         this.onStop();\n//       }\n//       this.active = false;\n//     }\n//   }\n// }\n\n// function cleanupEffect(effect) {\n//   // 找到所有依赖这个 effect 的响应式对象\n//   // 从这些响应式对象里面把 effect 给删除掉\n//   effect.deps.forEach((dep) => {\n//     dep.delete(effect);\n//   });\n\n//   effect.deps.length = 0;\n// }\n\n// export function effect(fn, options = {}) {\n//   const _effect = new ReactiveEffect(fn);\n\n//   // 把用户传过来的值合并到 _effect 对象上去\n//   // 缺点就是不是显式的，看代码的时候并不知道有什么值\n//   extend(_effect, options);\n//   _effect.run();\n\n//   // 把 _effect.run 这个方法返回\n//   // 让用户可以自行选择调用的时机（调用 fn）\n//   const runner: any = _effect.run.bind(_effect);\n//   runner.effect = _effect;\n//   return runner;\n// }\n\n// export function stop(runner) {\n//   runner.effect.stop();\n// }\n\n// export function track(target, type, key) {\n//   if (!isTracking()) {\n//     return;\n//   }\n//   console.log(`触发 track -> target: ${target} type:${type} key:${key}`);\n//   // 1. 先基于 target 找到对应的 dep\n//   // 如果是第一次的话，那么就需要初始化\n//   let depsMap = targetMap.get(target);\n//   if (!depsMap) {\n//     // 初始化 depsMap 的逻辑\n//     depsMap = new Map();\n//     targetMap.set(target, depsMap);\n//   }\n\n//   let dep = depsMap.get(key);\n\n//   if (!dep) {\n//     dep = createDep();\n\n//     depsMap.set(key, dep);\n//   }\n\n//   trackEffects(dep);\n// }\n\n// export function trackEffects(dep) {\n//   // 用 dep 来存放所有的 effect\n\n//   // TODO\n//   // 这里是一个优化点\n//   // 先看看这个依赖是不是已经收集了，\n//   // 已经收集的话，那么就不需要在收集一次了\n//   // 可能会影响 code path change 的情况\n//   // 需要每次都 cleanupEffect\n//   // shouldTrack = !dep.has(activeEffect!);\n//   if (!dep.has(activeEffect)) {\n//     dep.add(activeEffect);\n//     (activeEffect as any).deps.push(dep);\n//   }\n// }\n\n// export function trigger(target, type, key) {\n//   // 1. 先收集所有的 dep 放到 deps 里面，\n//   // 后面会统一处理\n//   let deps: Array<any> = [];\n//   // dep\n\n//   const depsMap = targetMap.get(target);\n\n//   if (!depsMap) return;\n\n//   // 暂时只实现了 GET 类型\n//   // get 类型只需要取出来就可以\n//   const dep = depsMap.get(key);\n\n//   // 最后收集到 deps 内\n//   deps.push(dep);\n\n//   const effects: Array<any> = [];\n//   deps.forEach((dep) => {\n//     // 这里解构 dep 得到的是 dep 内部存储的 effect\n//     effects.push(...dep);\n//   });\n//   // 这里的目的是只有一个 dep ，这个dep 里面包含所有的 effect\n//   // 这里的目前应该是为了 triggerEffects 这个函数的复用\n//   triggerEffects(createDep(effects));\n// }\n\n// export function isTracking() {\n//   return shouldTrack && activeEffect !== undefined;\n// }\n\n// export function triggerEffects(dep) {\n//   // 执行收集到的所有的 effect 的 run 方法\n//   for (const effect of dep) {\n//     if (effect.scheduler) {\n//       // scheduler 可以让用户自己选择调用的时机\n//       // 这样就可以灵活的控制调用了\n//       // 在 runtime-core 中，就是使用了 scheduler 实现了在 next ticker 中调用的逻辑\n//       effect.scheduler();\n//     } else {\n//       effect.run();\n//     }\n//   }\n// }\n","import { track, trigger } from \"./effect\";\n\nexport function reactive(raw) {\n  return new Proxy(raw, {\n    get(target, key) {\n      const res = Reflect.get(target, key);\n      // track\n      track(target, key);\n      // console.log(\"触发get\");\n      return res;\n    },\n    set(target, key, value) {\n      const res = Reflect.set(target, key, value);\n      // trigger\n      trigger(target, key);\n      // console.log(\"触发set\");\n      return res;\n    },\n  });\n}\n\nexport function readonly(raw) {\n  return new Proxy(raw, {\n    get(target, key) {\n      const res = Reflect.get(target, key);\n      // track\n      // console.log(\"触发get\");\n      return res;\n    },\n    set(target, key, value) {\n      return true\n    },\n  });\n}\n\n// import {\n//   mutableHandlers,\n//   readonlyHandlers,\n//   shallowReadonlyHandlers,\n// } from \"./baseHandlers\";\n\n// export const reactiveMap = new WeakMap();\n// export const readonlyMap = new WeakMap();\n// export const shallowReadonlyMap = new WeakMap();\n\n// export const enum ReactiveFlags {\n//   IS_REACTIVE = \"__v_isReactive\",\n//   IS_READONLY = \"__v_isReadonly\",\n//   RAW = \"__v_raw\",\n// }\n\n// export function reactive(target) {\n//   return createReactiveObject(target, reactiveMap, mutableHandlers);\n// }\n\n// export function readonly(target) {\n//   return createReactiveObject(target, readonlyMap, readonlyHandlers);\n// }\n\n// export function shallowReadonly(target) {\n//   return createReactiveObject(\n//     target,\n//     shallowReadonlyMap,\n//     shallowReadonlyHandlers\n//   );\n// }\n\n// export function isProxy(value) {\n//   return isReactive(value) || isReadonly(value);\n// }\n\n// export function isReadonly(value) {\n//   return !!value[ReactiveFlags.IS_READONLY];\n// }\n\n// export function isReactive(value) {\n//   // 如果 value 是 proxy 的话\n//   // 会触发 get 操作，而在 createGetter 里面会判断\n//   // 如果 value 是普通对象的话\n//   // 那么会返回 undefined ，那么就需要转换成布尔值\n//   return !!value[ReactiveFlags.IS_REACTIVE];\n// }\n\n// export function toRaw(value) {\n//   // 如果 value 是 proxy 的话 ,那么直接返回就可以了\n//   // 因为会触发 createGetter 内的逻辑\n//   // 如果 value 是普通对象的话，\n//   // 我们就应该返回普通对象\n//   // 只要不是 proxy ，只要是得到了 undefined 的话，那么就一定是普通对象\n//   // TODO 这里和源码里面实现的不一样，不确定后面会不会有问题\n//   if (!value[ReactiveFlags.RAW]) {\n//     return value;\n//   }\n\n//   return value[ReactiveFlags.RAW];\n// }\n\n// function createReactiveObject(target, proxyMap, baseHandlers) {\n//   // 核心就是 proxy\n//   // 目的是可以侦听到用户 get 或者 set 的动作\n\n//   // 如果命中的话就直接返回就好了\n//   // 使用缓存做的优化点\n//   const existingProxy = proxyMap.get(target);\n//   if (existingProxy) {\n//     return existingProxy;\n//   }\n\n//   const proxy = new Proxy(target, baseHandlers);\n\n//   // 把创建好的 proxy 给存起来，\n//   proxyMap.set(target, proxy);\n//   return proxy;\n// }\n"],"mappings":";;;AAkBO,MAAM,SAAS,OAAO;;;AChB7B,MAAI;AACG,MAAM,iBAAN,MAAqB;AAAA,IAK1B,YAAmB,IAAW,WAAY;AAAvB;AAAW;AAAA,IAAa;AAAA,IAJ3C,OAAO,CAAC;AAAA,IACR,aAAa;AAAA,IAEb;AAAA,IAEA,MAAM;AACJ,qBAAe;AACf,aAAO,KAAK,GAAG;AAAA,IACjB;AAAA,IACA,OAAO;AACL,UAAI,KAAK,YAAY;AACnB,sBAAc,IAAI;AAClB,YAAI,KAAK,QAAQ;AACf,eAAK,OAAO;AAAA,QACd;AACA,aAAK,aAAa;AAAA,MACpB;AAAA,IACF;AAAA,EACF;AACA,WAAS,cAAcA,SAAQ;AAC7B,IAAAA,QAAO,KAAK,QAAQ,CAAC,QAAa;AAChC,UAAI,OAAOA,OAAM;AAAA,IACnB,CAAC;AAAA,EACH;AACA,MAAM,YAAY,oBAAI,IAAI;AACnB,WAAS,MAAM,QAAQ,KAAK;AAEjC,QAAI,UAAU,UAAU,IAAI,MAAM;AAClC,QAAI,CAAC,SAAS;AACZ,gBAAU,oBAAI,IAAI;AAClB,gBAAU,IAAI,QAAQ,OAAO;AAAA,IAC/B;AACA,QAAI,MAAM,QAAQ,IAAI,GAAG;AACzB,QAAI,CAAC,KAAK;AACR,YAAM,oBAAI,IAAI;AACd,cAAQ,IAAI,KAAK,GAAG;AAAA,IACtB;AACA,QAAI,CAAC;AAAc;AAGnB,QAAI,IAAI,YAAY;AACpB,iBAAa,KAAK,KAAK,GAAG;AAAA,EAC5B;AAEO,WAAS,QAAQ,QAAQ,KAAK;AAEnC,QAAI,UAAU,UAAU,IAAI,MAAM;AAClC,QAAI,MAAM,QAAQ,IAAI,GAAG;AACzB,eAAWA,WAAU,KAAK;AACxB,UAAIA,QAAO,WAAW;AACpB,QAAAA,QAAO,UAAU;AAAA,MACnB,OAAO;AACL,QAAAA,QAAO,IAAI;AAAA,MACb;AAAA,IACF;AAAA,EACF;AAEO,WAAS,OAAO,IAAI,UAAe,CAAC,GAAG;AAC5C,UAAM,UAAU,IAAI,eAAe,IAAI,QAAQ,SAAS;AACxD,WAAO,SAAS,OAAO;AACvB,YAAQ,IAAI,OAAO;AACnB,YAAQ,IAAI;AACZ,UAAM,SAAc,QAAQ,IAAI,KAAK,OAAO;AAC5C,WAAO,SAAS;AAChB,WAAO;AAAA,EACT;;;ACnEO,WAAS,SAAS,KAAK;AAC5B,WAAO,IAAI,MAAM,KAAK;AAAA,MACpB,IAAI,QAAQ,KAAK;AACf,cAAM,MAAM,QAAQ,IAAI,QAAQ,GAAG;AAEnC,cAAM,QAAQ,GAAG;AAEjB,eAAO;AAAA,MACT;AAAA,MACA,IAAI,QAAQ,KAAK,OAAO;AACtB,cAAM,MAAM,QAAQ,IAAI,QAAQ,KAAK,KAAK;AAE1C,gBAAQ,QAAQ,GAAG;AAEnB,eAAO;AAAA,MACT;AAAA,IACF,CAAC;AAAA,EACH;","names":["effect"]}