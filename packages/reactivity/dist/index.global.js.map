{"version":3,"sources":["../src/dep.ts","../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts","../src/ref.ts","../src/computed.ts"],"sourcesContent":["// 用于存储所有的 effect 对象\nexport function createDep(effects?) {\n  const dep = new Set(effects);\n  return dep;\n}\n","export * from \"../src/shapeFlags\";\nexport * from \"../src/toDisplayString\";\n\nexport const isObject = (val) => {\n  return val !== null && typeof val === \"object\";\n};\n\nexport const isString = (val) => typeof val === \"string\";\n\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n * 把烤肉串命名方式转换成驼峰命名方式\n */\nexport const camelize = (str: string): string => {\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : \"\"));\n};\n\nexport const extend = Object.assign;\n\n// 必须是 on+一个大写字母的格式开头\nexport const isOn = (key) => /^on[A-Z]/.test(key);\n\nexport function hasChanged(value, oldValue) {\n  return !Object.is(value, oldValue);\n}\n\nexport function hasOwn(val, key) {\n  return Object.prototype.hasOwnProperty.call(val, key);\n}\n\n/**\n * @private\n * 首字母大写\n */\nexport const capitalize = (str: string) =>\n  str.charAt(0).toUpperCase() + str.slice(1);\n\n/**\n * @private\n * 添加 on 前缀，并且首字母大写\n */\nexport const toHandlerKey = (str: string) =>\n  str ? `on${capitalize(str)}` : ``;\n\n// 用来匹配 kebab-case 的情况\n// 比如 onTest-event 可以匹配到 T\n// 然后取到 T 在前面加一个 - 就可以\n// \\BT 就可以匹配到 T 前面是字母的位置\nconst hyphenateRE = /\\B([A-Z])/g;\n/**\n * @private\n */\nexport const hyphenate = (str: string) =>\n  str.replace(hyphenateRE, \"-$1\").toLowerCase();\n","import { createDep } from \"./dep\";\nimport { extend } from \"@relaxed/shared\";\n\nlet activeEffect = void 0;\nlet shouldTrack = false;\nconst targetMap = new WeakMap();\n\n// 用于依赖收集\nexport class ReactiveEffect {\n  active = true;\n  deps = [];\n  public onStop?: () => void;\n  constructor(public fn, public scheduler?) {\n    console.log(\"创建 ReactiveEffect 对象\");\n  }\n\n  run() {\n    console.log(\"run\");\n    // 运行 run 的时候，可以控制 要不要执行后续收集依赖的一步\n    // 目前来看的话，只要执行了 fn 那么就默认执行了收集依赖\n    // 这里就需要控制了\n\n    // 是不是收集依赖的变量\n\n    // 执行 fn  但是不收集依赖\n    if (!this.active) {\n      return this.fn();\n    }\n\n    // 执行 fn  收集依赖\n    // 可以开始收集依赖了\n    shouldTrack = true;\n\n    // 执行的时候给全局的 activeEffect 赋值\n    // 利用全局属性来获取当前的 effect\n    activeEffect = this as any;\n    // 执行用户传入的 fn\n    console.log(\"执行用户传入的 fn\");\n    const result = this.fn();\n    // 重置\n    shouldTrack = false;\n    activeEffect = undefined;\n\n    return result;\n  }\n\n  stop() {\n    if (this.active) {\n      // 如果第一次执行 stop 后 active 就 false 了\n      // 这是为了防止重复的调用，执行 stop 逻辑\n      cleanupEffect(this);\n      if (this.onStop) {\n        this.onStop();\n      }\n      this.active = false;\n    }\n  }\n}\n\nfunction cleanupEffect(effect) {\n  // 找到所有依赖这个 effect 的响应式对象\n  // 从这些响应式对象里面把 effect 给删除掉\n  effect.deps.forEach((dep) => {\n    dep.delete(effect);\n  });\n\n  effect.deps.length = 0;\n}\n\nexport function effect(fn, options = {}) {\n  const _effect = new ReactiveEffect(fn);\n\n  // 把用户传过来的值合并到 _effect 对象上去\n  // 缺点就是不是显式的，看代码的时候并不知道有什么值\n  extend(_effect, options);\n  _effect.run();\n\n  // 把 _effect.run 这个方法返回\n  // 让用户可以自行选择调用的时机（调用 fn）\n  const runner: any = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\n\nexport function stop(runner) {\n  runner.effect.stop();\n}\n\nexport function track(target, type, key) {\n  if (!isTracking()) {\n    return;\n  }\n  console.log(`触发 track -> target: ${target} type:${type} key:${key}`);\n  // 1. 先基于 target 找到对应的 dep\n  // 如果是第一次的话，那么就需要初始化\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    // 初始化 depsMap 的逻辑\n    depsMap = new Map();\n    targetMap.set(target, depsMap);\n  }\n\n  let dep = depsMap.get(key);\n\n  if (!dep) {\n    dep = createDep();\n\n    depsMap.set(key, dep);\n  }\n\n  trackEffects(dep);\n}\n\nexport function trackEffects(dep) {\n  // 用 dep 来存放所有的 effect\n\n  // TODO\n  // 这里是一个优化点\n  // 先看看这个依赖是不是已经收集了，\n  // 已经收集的话，那么就不需要在收集一次了\n  // 可能会影响 code path change 的情况\n  // 需要每次都 cleanupEffect\n  // shouldTrack = !dep.has(activeEffect!);\n  if (!dep.has(activeEffect)) {\n    dep.add(activeEffect);\n    (activeEffect as any).deps.push(dep);\n  }\n}\n\nexport function trigger(target, type, key) {\n  // 1. 先收集所有的 dep 放到 deps 里面，\n  // 后面会统一处理\n  let deps: Array<any> = [];\n  // dep\n\n  const depsMap = targetMap.get(target);\n\n  if (!depsMap) return;\n\n  // 暂时只实现了 GET 类型\n  // get 类型只需要取出来就可以\n  const dep = depsMap.get(key);\n\n  // 最后收集到 deps 内\n  deps.push(dep);\n\n  const effects: Array<any> = [];\n  deps.forEach((dep) => {\n    // 这里解构 dep 得到的是 dep 内部存储的 effect\n    effects.push(...dep);\n  });\n  // 这里的目的是只有一个 dep ，这个dep 里面包含所有的 effect\n  // 这里的目前应该是为了 triggerEffects 这个函数的复用\n  triggerEffects(createDep(effects));\n}\n\nexport function isTracking() {\n  return shouldTrack && activeEffect !== undefined;\n}\n\nexport function triggerEffects(dep) {\n  // 执行收集到的所有的 effect 的 run 方法\n  for (const effect of dep) {\n    if (effect.scheduler) {\n      // scheduler 可以让用户自己选择调用的时机\n      // 这样就可以灵活的控制调用了\n      // 在 runtime-core 中，就是使用了 scheduler 实现了在 next ticker 中调用的逻辑\n      effect.scheduler();\n    } else {\n      effect.run();\n    }\n  }\n}\n","import { ReactiveEffect, track, trigger } from \"./effect\";\nimport {\n  reactive,\n  ReactiveFlags,\n  reactiveMap,\n  readonly,\n  readonlyMap,\n  shallowReadonlyMap,\n} from \"./reactive\";\nimport { isObject } from \"@relaxed/shared\";\n\nconst get = createGetter();\nconst set = createSetter();\nconst readonlyGet = createGetter(true);\nconst shallowReadonlyGet = createGetter(true, true);\n\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target, key, receiver) {\n    const isExistInReactiveMap = () =>\n      key === ReactiveFlags.RAW && receiver === reactiveMap.get(target);\n\n    const isExistInReadonlyMap = () =>\n      key === ReactiveFlags.RAW && receiver === readonlyMap.get(target);\n\n    const isExistInShallowReadonlyMap = () =>\n      key === ReactiveFlags.RAW && receiver === shallowReadonlyMap.get(target);\n\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly;\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly;\n    } else if (\n      isExistInReactiveMap() ||\n      isExistInReadonlyMap() ||\n      isExistInShallowReadonlyMap()\n    ) {\n      return target;\n    }\n\n    const res = Reflect.get(target, key, receiver);\n\n    // 问题：为什么是 readonly 的时候不做依赖收集呢\n    // readonly 的话，是不可以被 set 的， 那不可以被 set 就意味着不会触发 trigger\n    // 所有就没有收集依赖的必要了\n\n    if (!isReadonly) {\n      // 在触发 get 的时候进行依赖收集\n      track(target, \"get\", key);\n    }\n\n    if (shallow) {\n      return res;\n    }\n\n    if (isObject(res)) {\n      // 把内部所有的是 object 的值都用 reactive 包裹，变成响应式对象\n      // 如果说这个 res 值是一个对象的话，那么我们需要把获取到的 res 也转换成 reactive\n      // res 等于 target[key]\n      return isReadonly ? readonly(res) : reactive(res);\n    }\n\n    return res;\n  };\n}\n\nfunction createSetter() {\n  return function set(target, key, value, receiver) {\n    const result = Reflect.set(target, key, value, receiver);\n\n    // 在触发 set 的时候进行触发依赖\n    trigger(target, \"set\", key);\n\n    return result;\n  };\n}\n\nexport const readonlyHandlers = {\n  get: readonlyGet,\n  set(target, key) {\n    // readonly 的响应式对象不可以修改值\n    console.warn(\n      `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n      target\n    );\n    return true;\n  },\n};\n\nexport const mutableHandlers = {\n  get,\n  set,\n};\n\nexport const shallowReadonlyHandlers = {\n  get: shallowReadonlyGet,\n  set(target, key) {\n    // readonly 的响应式对象不可以修改值\n    console.warn(\n      `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n      target\n    );\n    return true;\n  },\n};\n","import {\n  mutableHandlers,\n  readonlyHandlers,\n  shallowReadonlyHandlers,\n} from \"./baseHandlers\";\n\nexport const reactiveMap = new WeakMap();\nexport const readonlyMap = new WeakMap();\nexport const shallowReadonlyMap = new WeakMap();\n\nexport const enum ReactiveFlags {\n  IS_REACTIVE = \"__v_isReactive\",\n  IS_READONLY = \"__v_isReadonly\",\n  RAW = \"__v_raw\",\n}\n\nexport function reactive(target) {\n  return createReactiveObject(target, reactiveMap, mutableHandlers);\n}\n\nexport function readonly(target) {\n  return createReactiveObject(target, readonlyMap, readonlyHandlers);\n}\n\nexport function shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    shallowReadonlyMap,\n    shallowReadonlyHandlers\n  );\n}\n\nexport function isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\n\nexport function isReadonly(value) {\n  return !!value[ReactiveFlags.IS_READONLY];\n}\n\nexport function isReactive(value) {\n  // 如果 value 是 proxy 的话\n  // 会触发 get 操作，而在 createGetter 里面会判断\n  // 如果 value 是普通对象的话\n  // 那么会返回 undefined ，那么就需要转换成布尔值\n  return !!value[ReactiveFlags.IS_REACTIVE];\n}\n\nexport function toRaw(value) {\n  // 如果 value 是 proxy 的话 ,那么直接返回就可以了\n  // 因为会触发 createGetter 内的逻辑\n  // 如果 value 是普通对象的话，\n  // 我们就应该返回普通对象\n  // 只要不是 proxy ，只要是得到了 undefined 的话，那么就一定是普通对象\n  // TODO 这里和源码里面实现的不一样，不确定后面会不会有问题\n  if (!value[ReactiveFlags.RAW]) {\n    return value;\n  }\n\n  return value[ReactiveFlags.RAW];\n}\n\nfunction createReactiveObject(target, proxyMap, baseHandlers) {\n  // 核心就是 proxy\n  // 目的是可以侦听到用户 get 或者 set 的动作\n\n  // 如果命中的话就直接返回就好了\n  // 使用缓存做的优化点\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n\n  const proxy = new Proxy(target, baseHandlers);\n\n  // 把创建好的 proxy 给存起来，\n  proxyMap.set(target, proxy);\n  return proxy;\n}\n","import { trackEffects, triggerEffects, isTracking } from \"./effect\";\nimport { createDep } from \"./dep\";\nimport { isObject, hasChanged } from \"@relaxed/shared\";\nimport { reactive } from \"./reactive\";\n\nexport class RefImpl {\n  private _rawValue: any;\n  private _value: any;\n  public dep;\n  public __v_isRef = true;\n\n  constructor(value) {\n    this._rawValue = value;\n    // 看看value 是不是一个对象，如果是一个对象的话\n    // 那么需要用 reactive 包裹一下\n    this._value = convert(value);\n    this.dep = createDep();\n  }\n\n  get value() {\n    // 收集依赖\n    trackRefValue(this);\n    return this._value;\n  }\n\n  set value(newValue) {\n    // 当新的值不等于老的值的话，\n    // 那么才需要触发依赖\n    if (hasChanged(newValue, this._rawValue)) {\n      // 更新值\n      this._value = convert(newValue);\n      this._rawValue = newValue;\n      // 触发依赖\n      triggerRefValue(this);\n    }\n  }\n}\n\nexport function ref(value) {\n  return createRef(value);\n}\n\nfunction convert(value) {\n  return isObject(value) ? reactive(value) : value;\n}\n\nfunction createRef(value) {\n  const refImpl = new RefImpl(value);\n\n  return refImpl;\n}\n\nexport function triggerRefValue(ref) {\n  triggerEffects(ref.dep);\n}\n\nexport function trackRefValue(ref) {\n  if (isTracking()) {\n    trackEffects(ref.dep);\n  }\n}\n\n// 这个函数的目的是\n// 帮助解构 ref\n// 比如在 template 中使用 ref 的时候，直接使用就可以了\n// 例如： const count = ref(0) -> 在 template 中使用的话 可以直接 count\n// 解决方案就是通过 proxy 来对 ref 做处理\n\nconst shallowUnwrapHandlers = {\n  get(target, key, receiver) {\n    // 如果里面是一个 ref 类型的话，那么就返回 .value\n    // 如果不是的话，那么直接返回value 就可以了\n    return unRef(Reflect.get(target, key, receiver));\n  },\n  set(target, key, value, receiver) {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      return (target[key].value = value);\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  },\n};\n\n// 这里没有处理 objectWithRefs 是 reactive 类型的时候\n// TODO reactive 里面如果有 ref 类型的 key 的话， 那么也是不需要调用 ref.value 的\n// （but 这个逻辑在 reactive 里面没有实现）\nexport function proxyRefs(objectWithRefs) {\n  return new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\n\n// 把 ref 里面的值拿到\nexport function unRef(ref) {\n  return isRef(ref) ? ref.value : ref;\n}\n\nexport function isRef(value) {\n  return !!value.__v_isRef;\n}\n","import { createDep } from \"./dep\";\nimport { ReactiveEffect } from \"./effect\";\nimport { trackRefValue, triggerRefValue } from \"./ref\";\n\nexport class ComputedRefImpl {\n  public dep: any;\n  public effect: ReactiveEffect;\n\n  private _dirty: boolean;\n  private _value\n\n  constructor(getter) {\n    this._dirty = true;\n    this.dep = createDep();\n    this.effect = new ReactiveEffect(getter, () => {\n      // scheduler\n      // 只要触发了这个函数说明响应式对象的值发生改变了\n      // 那么就解锁，后续在调用 get 的时候就会重新执行，所以会得到最新的值\n      if (this._dirty) return;\n\n      this._dirty = true;\n      triggerRefValue(this);\n    });\n  }\n\n  get value() {\n    // 收集依赖\n    trackRefValue(this);\n    // 锁上，只可以调用一次\n    // 当数据改变的时候才会解锁\n    // 这里就是缓存实现的核心\n    // 解锁是在 scheduler 里面做的\n    if (this._dirty) {\n      this._dirty = false;\n      // 这里执行 run 的话，就是执行用户传入的 fn\n      this._value = this.effect.run();\n    }\n\n    return this._value;\n  }\n}\n\nexport function computed(getter) {\n  return new ComputedRefImpl(getter);\n}\n"],"mappings":"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","names":["effect","dep","isReadonly","get","set","ref"]}