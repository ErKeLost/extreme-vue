{"version":3,"sources":["../src/baseHandlers.ts","../src/effect.ts","../src/reactive.ts","../src/ref.ts"],"sourcesContent":["import { extend, isObject } from '@relaxed/shared'\r\nimport { track, trigger } from './effect'\r\nimport { reactive, ReactiveFlags, readonly } from './reactive'\r\n\r\n// 缓存一个getter & setter\r\nconst get = createGetter()\r\nconst set = createSetter()\r\nconst readonlyGet = createGetter(true)\r\nconst shallowReadonlyGet = createGetter(true, true)\r\n// 高阶函数判断逻辑\r\nexport function createGetter(isReadonly = false, shallow = false) {\r\n  return function get(target, key) {\r\n    const res = Reflect.get(target, key)\r\n    // track\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    }\r\n    if (shallow) {\r\n      return res\r\n    }\r\n    // 嵌套reactive 如果 res 返回的是一个 object 那么我们就再次调用\r\n    // 转换为reactive\r\n    if (isObject(res)) {\r\n      return isReadonly ? readonly(res) : reactive(res)\r\n    }\r\n    if (!isReadonly) {\r\n      track(target, key)\r\n    }\r\n    // console.log(\"触发get\");\r\n    return res\r\n  }\r\n}\r\n\r\nexport function createSetter() {\r\n  return function set(target, key, value) {\r\n    const res = Reflect.set(target, key, value)\r\n    // trigger\r\n    trigger(target, key)\r\n    // console.log(\"触发set\");\r\n    return res\r\n  }\r\n}\r\n\r\nexport const mutableHandlers = {\r\n  get,\r\n  set,\r\n}\r\nexport const readonlyHandlers = {\r\n  get: readonlyGet,\r\n  set(target, key, value) {\r\n    console.warn(`${key} is not change ${target} is read-only`)\r\n    return true\r\n  },\r\n}\r\n\r\nexport const shadowReadonlyHandlers = extend({}, readonlyHandlers, {\r\n  get: shallowReadonlyGet,\r\n})\r\n\r\n// import { ReactiveEffect, track, trigger } from \"./effect\";\r\n// import {\r\n//   reactive,\r\n//   ReactiveFlags,\r\n//   reactiveMap,\r\n//   readonly,\r\n//   readonlyMap,\r\n//   shallowReadonlyMap,\r\n// } from \"./reactive\";\r\n// import { isObject } from \"@relaxed/shared\";\r\n\r\n// const get = createGetter();\r\n// const set = createSetter();\r\n// const readonlyGet = createGetter(true);\r\n// const shallowReadonlyGet = createGetter(true, true);\r\n\r\n// function createGetter(isReadonly = false, shallow = false) {\r\n//   return function get(target, key, receiver) {\r\n//     const isExistInReactiveMap = () =>\r\n//       key === ReactiveFlags.RAW && receiver === reactiveMap.get(target);\r\n\r\n//     const isExistInReadonlyMap = () =>\r\n//       key === ReactiveFlags.RAW && receiver === readonlyMap.get(target);\r\n\r\n//     const isExistInShallowReadonlyMap = () =>\r\n//       key === ReactiveFlags.RAW && receiver === shallowReadonlyMap.get(target);\r\n\r\n//     if (key === ReactiveFlags.IS_REACTIVE) {\r\n//       return !isReadonly;\r\n//     } else if (key === ReactiveFlags.IS_READONLY) {\r\n//       return isReadonly;\r\n//     } else if (\r\n//       isExistInReactiveMap() ||\r\n//       isExistInReadonlyMap() ||\r\n//       isExistInShallowReadonlyMap()\r\n//     ) {\r\n//       return target;\r\n//     }\r\n\r\n//     const res = Reflect.get(target, key, receiver);\r\n\r\n//     // 问题：为什么是 readonly 的时候不做依赖收集呢\r\n//     // readonly 的话，是不可以被 set 的， 那不可以被 set 就意味着不会触发 trigger\r\n//     // 所有就没有收集依赖的必要了\r\n\r\n//     if (!isReadonly) {\r\n//       // 在触发 get 的时候进行依赖收集\r\n//       track(target, \"get\", key);\r\n//     }\r\n\r\n//     if (shallow) {\r\n//       return res;\r\n//     }\r\n\r\n//     if (isObject(res)) {\r\n//       // 把内部所有的是 object 的值都用 reactive 包裹，变成响应式对象\r\n//       // 如果说这个 res 值是一个对象的话，那么我们需要把获取到的 res 也转换成 reactive\r\n//       // res 等于 target[key]\r\n//       return isReadonly ? readonly(res) : reactive(res);\r\n//     }\r\n\r\n//     return res;\r\n//   };\r\n// }\r\n\r\n// function createSetter() {\r\n//   return function set(target, key, value, receiver) {\r\n//     const result = Reflect.set(target, key, value, receiver);\r\n\r\n//     // 在触发 set 的时候进行触发依赖\r\n//     trigger(target, \"set\", key);\r\n\r\n//     return result;\r\n//   };\r\n// }\r\n\r\n// export const readonlyHandlers = {\r\n//   get: readonlyGet,\r\n//   set(target, key) {\r\n//     // readonly 的响应式对象不可以修改值\r\n//     console.warn(\r\n//       `Set operation on key \"${String(key)}\" failed: target is readonly.`,\r\n//       target\r\n//     );\r\n//     return true;\r\n//   },\r\n// };\r\n\r\n// export const mutableHandlers = {\r\n//   get,\r\n//   set,\r\n// };\r\n\r\n// export const shallowReadonlyHandlers = {\r\n//   get: shallowReadonlyGet,\r\n//   set(target, key) {\r\n//     // readonly 的响应式对象不可以修改值\r\n//     console.warn(\r\n//       `Set operation on key \"${String(key)}\" failed: target is readonly.`,\r\n//       target\r\n//     );\r\n//     return true;\r\n//   },\r\n// };\r\n","import { extend } from '@relaxed/shared'\r\n\r\nlet activeEffect\r\nlet shouldTrack\r\nexport class ReactiveEffect {\r\n  deps = []\r\n  activeStop = true\r\n  // 可有可无\r\n  onStop?: () => void\r\n  constructor(public fn, public scheduler?) {}\r\n  run() {\r\n    // 1. 会收集依赖\r\n    if (!this.activeStop) {\r\n      return this.fn()\r\n    }\r\n    shouldTrack = true\r\n    activeEffect = this\r\n    const res = this.fn()\r\n    shouldTrack = false\r\n    return res\r\n  }\r\n  stop() {\r\n    if (this.activeStop) {\r\n      cleanupEffect(this)\r\n      if (this.onStop) {\r\n        this.onStop()\r\n      }\r\n      this.activeStop = false\r\n    }\r\n  }\r\n}\r\nfunction cleanupEffect(effect) {\r\n  effect.deps.forEach((dep: any) => {\r\n    dep.delete(effect)\r\n  })\r\n  effect.deps.length = 0\r\n}\r\nconst targetMap = new Map()\r\nexport function track(target, key) {\r\n  // 一开始没有 activeEffect\r\n  // if (!activeEffect) return\r\n  // 防止 同时触发 get 和 set 操作 他还是会收集到依赖 stop 会失效\r\n  // if (!shouldTrack) return\r\n  if (!isTracking()) {\r\n    return\r\n  }\r\n  // target -> key -> dep\r\n  let depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    depsMap = new Map()\r\n    targetMap.set(target, depsMap)\r\n  }\r\n  let dep = depsMap.get(key)\r\n  if (!dep) {\r\n    dep = new Set()\r\n    depsMap.set(key, dep)\r\n  }\r\n  trackEffect(dep)\r\n}\r\nexport function trackEffect(dep) {\r\n  if (dep.has(activeEffect)) return\r\n  dep.add(activeEffect)\r\n  activeEffect.deps.push(dep)\r\n}\r\n\r\nexport function triggerEffect(dep) {\r\n  for (const effect of dep) {\r\n    if (effect.scheduler) {\r\n      effect.scheduler()\r\n    } else {\r\n      effect.run()\r\n    }\r\n  }\r\n}\r\nexport function trigger(target, key) {\r\n  // 取出所有 收集到的依赖 进行遍历\r\n  let depsMap = targetMap.get(target)\r\n  let dep = depsMap.get(key)\r\n  triggerEffect(dep)\r\n}\r\n\r\nexport function effect(fn, options: any = {}) {\r\n  const _effect = new ReactiveEffect(fn, options.scheduler)\r\n  extend(_effect, options)\r\n  console.log(_effect)\r\n  _effect.run()\r\n  const runner: any = _effect.run.bind(_effect)\r\n  runner.effect = _effect\r\n  return runner\r\n}\r\n\r\nexport function isTracking() {\r\n  return shouldTrack && activeEffect !== undefined\r\n}\r\nexport function stop(runner) {\r\n  runner.effect.stop()\r\n}\r\n\r\n// import { createDep } from \"./dep\";\r\n// import { extend } from \"@relaxed/shared\";\r\n\r\n// let activeEffect = void 0;\r\n// let shouldTrack = false;\r\n// const targetMap = new WeakMap();\r\n\r\n// // 用于依赖收集\r\n// export class ReactiveEffect {\r\n//   active = true;\r\n//   deps = [];\r\n//   public onStop?: () => void;\r\n//   constructor(public fn, public scheduler?) {\r\n//     console.log(\"创建 ReactiveEffect 对象\");\r\n//   }\r\n\r\n//   run() {\r\n//     console.log(\"run\");\r\n//     // 运行 run 的时候，可以控制 要不要执行后续收集依赖的一步\r\n//     // 目前来看的话，只要执行了 fn 那么就默认执行了收集依赖\r\n//     // 这里就需要控制了\r\n\r\n//     // 是不是收集依赖的变量\r\n\r\n//     // 执行 fn  但是不收集依赖\r\n//     if (!this.active) {\r\n//       return this.fn();\r\n//     }\r\n\r\n//     // 执行 fn  收集依赖\r\n//     // 可以开始收集依赖了\r\n//     shouldTrack = true;\r\n\r\n//     // 执行的时候给全局的 activeEffect 赋值\r\n//     // 利用全局属性来获取当前的 effect\r\n//     activeEffect = this as any;\r\n//     // 执行用户传入的 fn\r\n//     console.log(\"执行用户传入的 fn\");\r\n//     const result = this.fn();\r\n//     // 重置\r\n//     shouldTrack = false;\r\n//     activeEffect = undefined;\r\n\r\n//     return result;\r\n//   }\r\n\r\n//   stop() {\r\n//     if (this.active) {\r\n//       // 如果第一次执行 stop 后 active 就 false 了\r\n//       // 这是为了防止重复的调用，执行 stop 逻辑\r\n//       cleanupEffect(this);\r\n//       if (this.onStop) {\r\n//         this.onStop();\r\n//       }\r\n//       this.active = false;\r\n//     }\r\n//   }\r\n// }\r\n\r\n// function cleanupEffect(effect) {\r\n//   // 找到所有依赖这个 effect 的响应式对象\r\n//   // 从这些响应式对象里面把 effect 给删除掉\r\n//   effect.deps.forEach((dep) => {\r\n//     dep.delete(effect);\r\n//   });\r\n\r\n//   effect.deps.length = 0;\r\n// }\r\n\r\n// export function effect(fn, options = {}) {\r\n//   const _effect = new ReactiveEffect(fn);\r\n\r\n//   // 把用户传过来的值合并到 _effect 对象上去\r\n//   // 缺点就是不是显式的，看代码的时候并不知道有什么值\r\n//   extend(_effect, options);\r\n//   _effect.run();\r\n\r\n//   // 把 _effect.run 这个方法返回\r\n//   // 让用户可以自行选择调用的时机（调用 fn）\r\n//   const runner: any = _effect.run.bind(_effect);\r\n//   runner.effect = _effect;\r\n//   return runner;\r\n// }\r\n\r\n// export function stop(runner) {\r\n//   runner.effect.stop();\r\n// }\r\n\r\n// export function track(target, type, key) {\r\n//   if (!isTracking()) {\r\n//     return;\r\n//   }\r\n//   console.log(`触发 track -> target: ${target} type:${type} key:${key}`);\r\n//   // 1. 先基于 target 找到对应的 dep\r\n//   // 如果是第一次的话，那么就需要初始化\r\n//   let depsMap = targetMap.get(target);\r\n//   if (!depsMap) {\r\n//     // 初始化 depsMap 的逻辑\r\n//     depsMap = new Map();\r\n//     targetMap.set(target, depsMap);\r\n//   }\r\n\r\n//   let dep = depsMap.get(key);\r\n\r\n//   if (!dep) {\r\n//     dep = createDep();\r\n\r\n//     depsMap.set(key, dep);\r\n//   }\r\n\r\n//   trackEffects(dep);\r\n// }\r\n\r\n// export function trackEffects(dep) {\r\n//   // 用 dep 来存放所有的 effect\r\n\r\n//   // TODO\r\n//   // 这里是一个优化点\r\n//   // 先看看这个依赖是不是已经收集了，\r\n//   // 已经收集的话，那么就不需要在收集一次了\r\n//   // 可能会影响 code path change 的情况\r\n//   // 需要每次都 cleanupEffect\r\n//   // shouldTrack = !dep.has(activeEffect!);\r\n//   if (!dep.has(activeEffect)) {\r\n//     dep.add(activeEffect);\r\n//     (activeEffect as any).deps.push(dep);\r\n//   }\r\n// }\r\n\r\n// export function trigger(target, type, key) {\r\n//   // 1. 先收集所有的 dep 放到 deps 里面，\r\n//   // 后面会统一处理\r\n//   let deps: Array<any> = [];\r\n//   // dep\r\n\r\n//   const depsMap = targetMap.get(target);\r\n\r\n//   if (!depsMap) return;\r\n\r\n//   // 暂时只实现了 GET 类型\r\n//   // get 类型只需要取出来就可以\r\n//   const dep = depsMap.get(key);\r\n\r\n//   // 最后收集到 deps 内\r\n//   deps.push(dep);\r\n\r\n//   const effects: Array<any> = [];\r\n//   deps.forEach((dep) => {\r\n//     // 这里解构 dep 得到的是 dep 内部存储的 effect\r\n//     effects.push(...dep);\r\n//   });\r\n//   // 这里的目的是只有一个 dep ，这个dep 里面包含所有的 effect\r\n//   // 这里的目前应该是为了 triggerEffects 这个函数的复用\r\n//   triggerEffects(createDep(effects));\r\n// }\r\n\r\n// export function isTracking() {\r\n//   return shouldTrack && activeEffect !== undefined;\r\n// }\r\n\r\n// export function triggerEffects(dep) {\r\n//   // 执行收集到的所有的 effect 的 run 方法\r\n//   for (const effect of dep) {\r\n//     if (effect.scheduler) {\r\n//       // scheduler 可以让用户自己选择调用的时机\r\n//       // 这样就可以灵活的控制调用了\r\n//       // 在 runtime-core 中，就是使用了 scheduler 实现了在 next ticker 中调用的逻辑\r\n//       effect.scheduler();\r\n//     } else {\r\n//       effect.run();\r\n//     }\r\n//   }\r\n// }\r\n","import { mutableHandlers, readonlyHandlers, shadowReadonlyHandlers } from './baseHandlers'\r\n\r\n// 是一个reactive\r\nexport const enum ReactiveFlags {\r\n  IS_REACTIVE = '_v_isReactive',\r\n  IS_READONLY = '_v_isReadonly',\r\n}\r\n// true  false 判断是否是 readonly\r\nexport function reactive(raw) {\r\n  return createReactiveObject(raw, mutableHandlers)\r\n}\r\n\r\nexport function readonly(raw) {\r\n  return createReactiveObject(raw, readonlyHandlers)\r\n}\r\n\r\nexport function shadowReadonly(raw) {\r\n  return createReactiveObject(raw, shadowReadonlyHandlers)\r\n}\r\n\r\nexport function isProxy(raw) {\r\n  return isReactive(raw) || isReadonly(raw)\r\n}\r\n\r\nexport function isReactive(raw) {\r\n  // 如果是原始对象没有 proxy 代理 是undefined 转成 boolean\r\n  return !!raw[ReactiveFlags.IS_REACTIVE]\r\n}\r\nexport function isReadonly(raw) {\r\n  return !!raw[ReactiveFlags.IS_READONLY]\r\n}\r\n\r\nfunction createReactiveObject(raw, Handlers) {\r\n  return new Proxy(raw, Handlers)\r\n}\r\n\r\n// import {\r\n//   mutableHandlers,\r\n//   readonlyHandlers,\r\n//   shallowReadonlyHandlers,\r\n// } from \"./baseHandlers\";\r\n\r\n// export const reactiveMap = new WeakMap();\r\n// export const readonlyMap = new WeakMap();\r\n// export const shallowReadonlyMap = new WeakMap();\r\n\r\n// export const enum ReactiveFlags {\r\n//   IS_REACTIVE = \"__v_isReactive\",\r\n//   IS_READONLY = \"__v_isReadonly\",\r\n//   RAW = \"__v_raw\",\r\n// }\r\n\r\n// export function reactive(target) {\r\n//   return createReactiveObject(target, reactiveMap, mutableHandlers);\r\n// }\r\n\r\n// export function readonly(target) {\r\n//   return createReactiveObject(target, readonlyMap, readonlyHandlers);\r\n// }\r\n\r\n// export function shallowReadonly(target) {\r\n//   return createReactiveObject(\r\n//     target,\r\n//     shallowReadonlyMap,\r\n//     shallowReadonlyHandlers\r\n//   );\r\n// }\r\n\r\n// export function isProxy(value) {\r\n//   return isReactive(value) || isReadonly(value);\r\n// }\r\n\r\n// export function isReadonly(value) {\r\n//   return !!value[ReactiveFlags.IS_READONLY];\r\n// }\r\n\r\n// export function isReactive(value) {\r\n//   // 如果 value 是 proxy 的话\r\n//   // 会触发 get 操作，而在 createGetter 里面会判断\r\n//   // 如果 value 是普通对象的话\r\n//   // 那么会返回 undefined ，那么就需要转换成布尔值\r\n//   return !!value[ReactiveFlags.IS_REACTIVE];\r\n// }\r\n\r\n// export function toRaw(value) {\r\n//   // 如果 value 是 proxy 的话 ,那么直接返回就可以了\r\n//   // 因为会触发 createGetter 内的逻辑\r\n//   // 如果 value 是普通对象的话，\r\n//   // 我们就应该返回普通对象\r\n//   // 只要不是 proxy ，只要是得到了 undefined 的话，那么就一定是普通对象\r\n//   // TODO 这里和源码里面实现的不一样，不确定后面会不会有问题\r\n//   if (!value[ReactiveFlags.RAW]) {\r\n//     return value;\r\n//   }\r\n\r\n//   return value[ReactiveFlags.RAW];\r\n// }\r\n\r\n// function createReactiveObject(target, proxyMap, baseHandlers) {\r\n//   // 核心就是 proxy\r\n//   // 目的是可以侦听到用户 get 或者 set 的动作\r\n\r\n//   // 如果命中的话就直接返回就好了\r\n//   // 使用缓存做的优化点\r\n//   const existingProxy = proxyMap.get(target);\r\n//   if (existingProxy) {\r\n//     return existingProxy;\r\n//   }\r\n\r\n//   const proxy = new Proxy(target, baseHandlers);\r\n\r\n//   // 把创建好的 proxy 给存起来，\r\n//   proxyMap.set(target, proxy);\r\n//   return proxy;\r\n// }\r\n","// import { trackEffects, triggerEffects, isTracking } from \"./effect\";\r\n// import { createDep } from \"./dep\";\r\nimport { isObject, hasChanged } from '@relaxed/shared'\r\nimport { reactive } from './reactive'\r\nimport { trackEffect, triggerEffect, isTracking } from './effect'\r\n\r\nclass RefImpl {\r\n  private _value: any\r\n  private _rawValue: any\r\n  // 创建一个dep 收集依赖\r\n  public dep\r\n  constructor(value) {\r\n    // 存储 原始普通对象的value值 用于对比\r\n    this._rawValue = value\r\n    this._value = convert(value)\r\n    // 判断value 是不是对象 是对象就装换成reactive\r\n\r\n    this.dep = new Set()\r\n  }\r\n  get value() {\r\n    trackRefValue(this)\r\n    // ref 只监听一个 value 的变化 value的依赖收集\r\n    return this._value\r\n  }\r\n  set value(newValue) {\r\n    // 如果value 是一个 对象 就会被转换成reactive 新的值 是 proxy 对比 要转换成普通对象\r\n    // if (hasChanged(newValue, this._value)) {\r\n    if (hasChanged(newValue, this._rawValue)) {\r\n      // if (Object.is(newValue, this._value)) return\r\n      // 必须要先修改value的值 再去通知\r\n      this._rawValue = newValue\r\n      this._value = convert(newValue)\r\n      triggerEffect(this.dep)\r\n    }\r\n  }\r\n}\r\n\r\nexport function ref(value) {\r\n  return new RefImpl(value)\r\n}\r\n\r\nfunction trackRefValue(ref) {\r\n  if (isTracking()) {\r\n    trackEffect(ref.dep)\r\n  }\r\n}\r\n\r\n// 判断 返回 reactive 对象 还是普通对象\r\nfunction convert(value) {\r\n  return isObject(value) ? reactive(value) : value;\r\n}\r\n\r\n\r\n// export class RefImpl {\r\n//   private _rawValue: any;\r\n//   private _value: any;\r\n//   public dep;\r\n//   public __v_isRef = true;\r\n\r\n//   constructor(value) {\r\n//     this._rawValue = value;\r\n//     // 看看value 是不是一个对象，如果是一个对象的话\r\n//     // 那么需要用 reactive 包裹一下\r\n//     this._value = convert(value);\r\n//     this.dep = createDep();\r\n//   }\r\n\r\n//   get value() {\r\n//     // 收集依赖\r\n//     trackRefValue(this);\r\n//     return this._value;\r\n//   }\r\n\r\n//   set value(newValue) {\r\n//     // 当新的值不等于老的值的话，\r\n//     // 那么才需要触发依赖\r\n//     if (hasChanged(newValue, this._rawValue)) {\r\n//       // 更新值\r\n//       this._value = convert(newValue);\r\n//       this._rawValue = newValue;\r\n//       // 触发依赖\r\n//       triggerRefValue(this);\r\n//     }\r\n//   }\r\n// }\r\n\r\n// export function ref(value) {\r\n//   return createRef(value);\r\n// }\r\n\r\n// function convert(value) {\r\n//   return isObject(value) ? reactive(value) : value;\r\n// }\r\n\r\n// function createRef(value) {\r\n//   const refImpl = new RefImpl(value);\r\n\r\n//   return refImpl;\r\n// }\r\n\r\n// export function triggerRefValue(ref) {\r\n//   triggerEffects(ref.dep);\r\n// }\r\n\r\n// export function trackRefValue(ref) {\r\n//   if (isTracking()) {\r\n//     trackEffects(ref.dep);\r\n//   }\r\n// }\r\n\r\n// // 这个函数的目的是\r\n// // 帮助解构 ref\r\n// // 比如在 template 中使用 ref 的时候，直接使用就可以了\r\n// // 例如： const count = ref(0) -> 在 template 中使用的话 可以直接 count\r\n// // 解决方案就是通过 proxy 来对 ref 做处理\r\n\r\n// const shallowUnwrapHandlers = {\r\n//   get(target, key, receiver) {\r\n//     // 如果里面是一个 ref 类型的话，那么就返回 .value\r\n//     // 如果不是的话，那么直接返回value 就可以了\r\n//     return unRef(Reflect.get(target, key, receiver));\r\n//   },\r\n//   set(target, key, value, receiver) {\r\n//     const oldValue = target[key];\r\n//     if (isRef(oldValue) && !isRef(value)) {\r\n//       return (target[key].value = value);\r\n//     } else {\r\n//       return Reflect.set(target, key, value, receiver);\r\n//     }\r\n//   },\r\n// };\r\n\r\n// // 这里没有处理 objectWithRefs 是 reactive 类型的时候\r\n// // TODO reactive 里面如果有 ref 类型的 key 的话， 那么也是不需要调用 ref.value 的\r\n// // （but 这个逻辑在 reactive 里面没有实现）\r\n// export function proxyRefs(objectWithRefs) {\r\n//   return new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n// }\r\n\r\n// // 把 ref 里面的值拿到\r\n// export function unRef(ref) {\r\n//   return isRef(ref) ? ref.value : ref;\r\n// }\r\n\r\n// export function isRef(value) {\r\n//   return !!value.__v_isRef;\r\n// }\r\n"],"mappings":"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","names":["extend","effect","get","set","extend","isObject","ref","isObject"]}